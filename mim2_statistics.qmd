---
title: "Mim2_Statistical_analyses"
author: "Bolívar Aponte Rolón"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: html_document
---

```{r setup}
knitr::opts_chunk$set(out.width ='70%', fig_align = 'center', echo = TRUE, collapse = TRUE, eval=FALSE)
```

##Potential Packages

```{r}

# Core packages
library("tidyverse")
library("data.table")
library("ggpubr")
library("ggfortify")
library("rstatix")
library("broom")


# Linear Models
library("car")
library("nlme")

# Community Diversity
library("vegan")
library("hillR")
library("geosphere")
library("indicspecies")

# ggplot2 extensions
library("ggtext")
library("ggpmisc")
library("MetBrewer")

# Phyloseq friendly
#Some of these are redundant and have conflicts, but have functions that I like better than others or compliment each other.
library("phyloseq")
library("microeco") # New package for microbial analyses
library("file2meco") # File to microeco (phyloseq friendly)
library("metagMisc") # Miscellaneous functions
library("microbiome") # Expands phyloseq 
library("mirlyn")

# Parallel processing
library("parallelly")

# Misc
library("conflicted")
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("alpha", "ggplot2")
```

# File Path

```{r}
#| echo: false
#| eval: true
#| tidy: true
path <- "../mim2_bioinformatics" # Change accordingly
```

# Objective of the notebook

The goal of this notebook is to explore the relationship between leaf endophytes of *Mimulus* spp. with elevation and host leaf traits. I attempt to analyze in every possible way by firs performing descriptive statistics and then the adequate analyses for each question. The notebook is meant to serves as a draft for the analyses I include in the manuscript. Because of this there will be some differences between the documents. The code here can be at times messy and not well organized. The manuscript document has all the refined code for plots and analyses. I try to keep both documents as similar as possible, but the manuscript document is the final product. Here you may find violin plots and the manuscript boxplots, things like that.

# Data sets

## Cleaning and Shaping

This section cleans and shapes the raw data into two main data frames: `leaf_traits` and `plant_traits`. The first has all data point for leaf trait measurements at the leaf level (raw) and the second one represents the average per plant while incorporating FEF community data. The FEF community data is only available for 160/320 samples. For the downstream analyses, we eliminated *M. bicolor* or species "B" from the leaf trait data set and the phyloseq object (see `mim2_bioinformatics.qmd`). The removal of this is due to a small sample size for leaf trait measurements and even smaller for FEF community data (*n* = 3). The removal is not explicit in `plant_traits` it is only explicit in the subset `leaf_traits_noB` and and phyloseq objects. This is important for the rarefaction of sequence dept and later on in the `asv_matrix` that gives way for community analyses in [Community Diversity]. I include a custom function for p-value formatting.

### Raw data sets


```{r, cleaning_chaping_data}
#| echo: false
#| eval: true
#| tidy: true

################################
########## RAW data sets #######
################################

traits <- read.csv(file.path(path, "field_data/mim2_leaf_traits_field_survey.csv")) # Main raw data set

#Elevation_m categories (meters)
breaks <- c(-Inf, 1219.2, 1828.495, Inf)
labels <- c("LOW", "MID", "HIGH")

#Leaf level data set
leaf_traits <-  traits |>
  slice(-c(959:973))|> #Removing control samples
  filter(!Unique_ID == "TRTB_L001") |>#Removing misidentified sample
  rename(LMA = LMA.mg., 
         LBI = Leaf_lobe_index,
         LPS = Leaf_toughness,
         LT = Leaf_thickness) |> 
  select(!c(5,13:15, 23:25)) |>
  group_by(Site, Species, Unique_ID) |>
  fill(ImageJ_1, ImageJ_2, LBI, .direction = 'down') |>
  mutate(Species = as.factor(Species), 
         Site = as.factor(Site),
         Elevation_cat = cut(Elevation_m, 
                             breaks = breaks,
                             labels = labels)) |>
  relocate(Elevation_cat, .before = Elevation_m)|>
  as_tibble()

#Plant level for ASV analyses
plant_traits <- leaf_traits |>
  relocate(Unique_ID, .before = Site) |>
  group_by(Unique_ID, Site, Species, Sample_Date, Elevation_m, Elevation_cat, Longitude, Latitude)|>
  summarise(ACI = mean(ACI, na.rm = TRUE),
            LT = mean(LT, na.rm = TRUE),
            LPS= mean(LPS, na.rm =TRUE),
            LMA = mean(LMA, na.rm = TRUE),
            ImageJ_1 = mean(ImageJ_1, na.rm = TRUE),
            ImageJ_2 = mean(ImageJ_2, na.rm = TRUE),
            LBI = mean(LBI, na.rm = TRUE))


#### Log transformation ####

# All variables are non-normal. I proceed with a log transformation of the data.
# See Descriptive Statistics section for reference on this decision. Leaf_trait_transformation block.
# Leaft traits transformed
leaf_traits <- leaf_traits |>
  mutate(logLBI = log10(LBI),
         logACI = log10(ACI),
         logLT = log10(LT),
         logLPS = log10(LPS),
         logLMA = log10(LMA))

#Removing species B
# I have 3 samples for species B to remove from the data set.
leaf_traits_noB <- leaf_traits |>
  filter(!Species == "M. bicolor")

# Plant traits transformed
plant_traits <- plant_traits |>
  mutate(logLBI = log10(LBI),
         logACI = log10(ACI),
         logLT = log10(LT),
         logLPS = log10(LPS),
         logLMA = log10(LMA))
```

### Phyloseq, mirl, and meco objects
```{r, phylo_objects}
###################################
#### Load Phyloseq objects ########
###################################
#Phyloseq joins various objects that we have already prepare: taxonomic table, ASV table and our sample data. These are the data frames resulting from the phyloseq section in mim2_bioinformatics.qmd notebook.

# Load Phyloseq object cleaned of singletons (231 ASVs)
ps_clean_3 <- readRDS(file.path(path, "clean_data/taxonomy/TAXA_8450_phyloseq_nonsingletons_noB.rds"))
ps_clean_3_df  <- read.csv(file.path(path, "clean_data/taxonomy/TAXA_8450_phyloseq_nonsingletons_noB.csv"))
pseq_rrfb <- readRDS(file.path(path, "clean_data/statistics/pseq_rrfb.rds")) #Mirlyn object from Method B
rarefied_phyloseq <- readRDS(file.path(path, "clean_data/statistics/rarefied_phyloseq.rds"))
```

### Leaf traits with community data

```{r}
#### Leaf traits with community data ####
# Calculating Hill orders on non-rarefied data
# The estimate_richness() is meant to be used with untrimmed data. It is highly dependnet on singletons. My data is already trimmed and decontaminated. My singleton "removal" eliminates ASVs with all zeros or samples wil all zeros. Singletons do remain, so this is not a problem.
plant_traits <- ps_clean_3 |> #Estimating community richness and shannon diversity from phyloseq object
  estimate_richness(split = TRUE, measures = c("Observed","Shannon", "Simpson")) |>
       #  Simpson = 1 / Simpson) |>
  mutate(hill_1 = exp(Shannon), #Observed column is equivalent to hill_0
         hill_2 = 1/(1 - Simpson)) |> #Simpson index is (1-D) and InvSimpson (1/D) which is equivalent to hill_2
  rownames_to_column() |>
  rename(Unique_ID = rowname) |>
  right_join(plant_traits, by = "Unique_ID") |>
  relocate(Observed, 
           Shannon, 
           Simpson, 
           hill_1,
           hill_2,
           .after = logLMA) |>
  rename(Simpson_1minusD = Simpson)
# See https://www.jak.bio/posts/me/20211227_simpson/simpson_diversity.html for a good explanation of Simpson's diversity index.

# Melt data  frame from ps_clean_3
ps_melt <- ps_clean_3 |>
  psmelt() |>
  # group_by(Phylum, Elevation_cat) |>
  # mutate(mean_abundance = mean(Abundance), 
  #        se = sd(Abundance)/sqrt(length(Abundance)),
  #        sd = sd(Abundance),
  #        sample_Species = factor(sample_Species)) |>
  # ungroup() |>
  rename(Unique_ID = Sample, ASV = OTU) |> #Renaming OTU column
  dplyr::select(!c(11:17))  #Reordering columns 
#This data frame is useful for barplots and other visualizations.


##########################################################
############### Save files after changes #################
##########################################################
# Save file
# Leaf traits
# saveRDS(leaf_traits, file.path(path, "clean_data/statistics/leaf_traits.rds"))
# write.csv(leaf_traits, file.path(path, "clean_data/statistics/leaf_traits.csv"))
# 
# # Plant traits with community data
# saveRDS(plant_traits, file.path(path, "clean_data/statistics/plant_traits.rds"))
# write.csv(plant_traits, file.path(path, "clean_data/statistics/plant_traits.csv"))
# 
# # Save ps_melt
# saveRDS(ps_melt, file.path(path, "clean_data/statistics/ps_melt.rds"))
# write.csv(ps_melt, file.path(path, "clean_data/statistics/ps_melt.csv"))
```

### Load files
```{r}
#####################################################
############### Load master files here ##############
#####################################################
leaf_traits <- readRDS(file.path(path, "clean_data/statistics/leaf_traits.rds")) # Post all the processing aboove, lod from here.
plant_traits <- readRDS(file.path(path, "clean_data/statistics/plant_traits.rds"))
plant_traits_MB <- readRDS(file.path(path, "clean_data/statistics/plant_traits_MB.rds"))
ps_melt <- readRDS(file.path(path, "clean_data/statistics/ps_melt.rds"))

# Samples with species to subset/filter matrices downstream
# M. laciniatus
lac_names <- plant_traits |>
  slice(1:157) |> # Only selecting observations with ASV data 
  filter(Species == "M. laciniatus") |>
  pull(Unique_ID) 

# M. guttatus
gut_names <- plant_traits |> 
  slice(1:157) |> # Only selecting observations with ASV data 
  filter(Species == "M. guttatus") |>
  pull(Unique_ID)

# M. nasutus
nas_names <- plant_traits |> 
  slice(1:157) |> # Only selecting observations with ASV data 
  filter(Species == "M. nasutus") |>
  pull(Unique_ID)

# Functions
source("functions/alpha_rfy.R")
source("functions/pval_format.R")

# Comparisons
my_comparisons <- list(c("M. nasutus", "M. laciniatus"), c("M. nasutus", "M. guttatus"), c("M. laciniatus", "M. guttatus"))
my_comparisons3 <- list(c("LOW", "MID"), c("LOW", "HIGH"), c("MID", "HIGH"))

# List of ASV samples
names_list <- colnames(ps_clean_3@otu_table) #List of samples

#Subset data set for NMDS and dbRDA plot
# Samples resulting from rarefaction
#ordi_traits <- plant_traits |>
#  filter(Unique_ID %in% final_names_methodB)
```

## Descriptive stats

```{r, Leaf_traits_basics}
#| echo: false
#| eval: true
#| tidy: true
# Sites and Species sampled
leaf_traits_noB |>
  group_by(Site,Species, Longitude, Latitude) |>
  summarise(n = as.integer(n()/3))|> # Dividing by 3 due to replicate measurments of each sample
  pivot_wider(names_from = Species, values_from = n)|>
  knitr::kable(caption = "Number of samples per population/site and species.")

#LBI
hist(leaf_traits$LBI) #Skewed to the left, non-normal distribution of LBI data
mean(leaf_traits$LBI, na.rm = TRUE)
max(leaf_traits$LBI, na.rm = TRUE)
min(leaf_traits$LBI, na.rm = TRUE)
sd(leaf_traits$LBI, na.rm = TRUE)

qqPlot(leaf_traits$LBI) #Does not seem normal at all.
hist(rnorm(n = length(leaf_traits$LBI))) #For comparison: normal distribution based on random permutation of my data.
shapiro.test(leaf_traits$LBI) #Since p-value is less than 0.05 this means the residuals from the LBI data are not normally distributed. Data needs transfromation.
fligner.test(logLBI ~ Site, data = leaf_traits) #Homogeneity of variances test. p-value < 0.05, variances are not equal.

#LMA
hist(leaf_traits$LMA)
mean(leaf_traits$LMA, na.rm = TRUE)
max(leaf_traits$LMA, na.rm = TRUE)
min(leaf_traits$LMA, na.rm = TRUE)
sd(leaf_traits$LMA, na.rm = TRUE)

qqPlot(leaf_traits$LMA) #Remove outiler 4.4mg
#hist(rnorm(n = length(leaf_traits$LMA))) #For comparison: normal distribution based on random permutation of my data.
shapiro.test(leaf_traits$LMA) #Since p-value is less than 0.05 this means the residuals from the LMA data are not normally distributed.
fligner.test(LMA ~ Site, data = leaf_traits) #Homogeneity of variances test. p-value < 0.05, variances are not equal.

#Toughness
hist(leaf_traits$LPS[leaf_traits$LPS < 4]) # Remove two outliers by using cut-off at 4.
mean(leaf_traits$LPS[leaf_traits$LPS < 4], na.rm = TRUE)
max(leaf_traits$LPS[leaf_traits$LPS < 4], na.rm = TRUE)
min(leaf_traits$LPS[leaf_traits$LPS < 4], na.rm = TRUE)
sd(leaf_traits$LPS[leaf_traits$LPS < 4], na.rm = TRUE)

qqPlot(leaf_traits$LPS[leaf_traits$LPS < 4]) 
hist(rnorm(n = length(leaf_traits$LPS[leaf_traits$LPS < 4]))) #For comparison: normal distribution based on random permutation of my data.
shapiro.test(leaf_traits$LPS[leaf_traits$LPS < 4]) #Since p-value is less than 0.05 this means the residuals from the LPS data are not normally distributed. Data needs transformation.
fligner.test(LPS ~ Site, data = leaf_traits) #Homogeneity of variances test. p-value < 0.05, variances are not equal.

#Thickness
hist(leaf_traits$LT)
mean(leaf_traits$LT, na.rm = TRUE)
max(leaf_traits$LT, na.rm = TRUE)
min(leaf_traits$LT, na.rm = TRUE)
sd(leaf_traits$LT, na.rm = TRUE)

qqPlot(leaf_traits$LT) # Skewed to the right. 
hist(rnorm(n = length(leaf_traits$LT))) #For comparison: normal distribution based on random permutation of my data.
shapiro.test(leaf_traits$LT) #Since p-value is less than 0.05 this means the residuals from the LT data are not normally distributed. Data needs transformation.
fligner.test(LT ~ Site, data = leaf_traits) #Homogeneity of variances test. p-value < 0.05, variances are not equal.

#ACI
hist(leaf_traits$ACI[leaf_traits$ACI < 20]) #Setting cut-off at 20 to remove outliers. 
mean(leaf_traits$ACI[leaf_traits$ACI <20], na.rm = TRUE)
max(leaf_traits$ACI, na.rm = TRUE)
min(leaf_traits$ACI, na.rm = TRUE)
sd(leaf_traits$ACI[leaf_traits$ACI <20], na.rm = TRUE)

qqPlot(leaf_traits$ACI[leaf_traits$ACI <20]) # Remove outliers, it's is skewed to the right. 
hist(rnorm(n = length(leaf_traits$ACI))) #For comparison: normal distribution based on random permutation of my data.
shapiro.test(leaf_traits$ACI[leaf_traits$ACI <20]) #Since p-value is less than 0.05 this means the residuals from the Thickness data are not normally distributed. Data needs transformation.
fligner.test(ACI ~ Site, data = leaf_traits) #Homogeneity of variances test. p-value < 0.05, variances are not equal.

#Elevation_m
hist(leaf_traits$Elevation_m)
mean(leaf_traits$Elevation_m, na.rm = TRUE)
max(leaf_traits$Elevation_m, na.rm = TRUE)
min(leaf_traits$Elevation_m, na.rm = TRUE)
sd(leaf_traits$Elevation_m, na.rm = TRUE)

qqPlot(leaf_traits$Elevation_m) 
hist(rnorm(n = length(leaf_traits$Elevation_m))) #For comparison: normal distribution based on random permutation of my data.
shapiro.test(leaf_traits$Elevation_m) #Since p-value is less than 0.05 this means the residuals from the Thickness data are not normally distributed. Data needs transformation.
fligner.test(Elevation_m ~ Site, data = leaf_traits) #Homogeneity of variances test. p-value < 0.05, variances are not equal.
```

All leaf traits and elevation are not normally distributed. This requires transformation for further analysis. I will proceed with a log transformation of the data.

```{r, Leaf_traits_transformation}

# Leaf traits transformed
# leaf_traits <- leaf_traits |>
#   mutate(logLBI = log10(LBI),
#          logACI = log10(ACI),
#          logLT = log10(Thickness),
#          logLPS = log10(Toughness),
#          logLMA = log10(LMA))
# 
# #Removing species B
# leaf_traits_noB <- leaf_traits |>
#   filter(!Species == "B")
# 
# # Plant traits transformed
# plant_traits <- plant_traits |>
#   mutate(logLBI = log10(LBI),
#          logACI = log10(ACI),
#          logLT = log10(Thickness),
#          logLPS = log10(Toughness),
#          logLMA = log10(LMA))
```

I will not omiting samples with NAs because some have the complete data for some leaf traits and not for others. I will omit samples with NAs for the Fungal analyses.

## Post data transformations

```{r, post_transformation}
#| echo: false
#| eval: true
#| tidy: true

#LBI
hist(leaf_traits$LBI, col = "steelblue", main = "Non-normal distribution")
hist(na.omit(leaf_traits$logLBI), col='coral2', main='Log Transformed')
qqPlot(leaf_traits$logLBI) #a BETTER, but not normal distribution
shapiro.test(leaf_traits$logLBI)

#LMA
hist(leaf_traits$LMA, col = "steelblue", main = "Non-normal distribution")
hist(na.omit(leaf_traits$logLMA), col='coral2', main='Log Transformed')
qqPlot(na.omit(leaf_traits$logLMA)) 
shapiro.test(na.omit(leaf_traits$logLMA))

#Toughness
hist(leaf_traits$Toughness[leaf_traits$Toughness < 4], col = "steelblue", main = "Non-normal distribution")
hist(na.omit(leaf_traits$logLPS[leaf_traits$logLPS < 0.5]), col='coral2', main='Log Transformed')
qqPlot(leaf_traits$logLPS[leaf_traits$logLPS < 0.5]) # Excludinfg the outliers, this transformation looks good
shapiro.test(leaf_traits$logLPS) # It still does not meet normality assumptions.

#Thickness
hist(leaf_traits$Thickness, col = "steelblue", main = "Non-normal distribution")
hist(na.omit(leaf_traits$logLT), col='coral2', main='Log Transformed')
qqPlot(leaf_traits$logLT)
shapiro.test(leaf_traits$logLT) #Close to normality, but not quite there.

#ACI
hist(leaf_traits$ACI, col = "steelblue", main = "Non-normal distribution")
hist(na.omit(leaf_traits$logACI), col='coral2', main='Log Transformed')
qqPlot(leaf_traits$logACI) 
shapiro.test(leaf_traits$logACI) #Another transformation that does not meet normality assumptions.
```

The log transformations improve the normality of the data, but it does not meet the assumptions for normality. I will proceed with the analyses using the log transformed data. I will use non-parametric tests for the analyses.

## Non-parametric tests

```{r, non_parametric}
#M1 <- lme(logLBI ~ , method = "REML", data = imagej1) # this is not the best given that I don't have continuous data.

#Kruskal-Wallis
#Because the data does not meet normality assumptions after transformation, I decisded to stick to a non-parametric test like Kruskal-Wallis.
# LBI by Site
print(kruskal.test(logLBI ~ Site, 
                   data = leaf_traits,
                   na.action = na.omit))

# LBI by Elevation_m
print(kruskal.test(logLBI ~ Elevation_m, 
             data = leaf_traits,
             na.action = na.omit))

# LMA by Site
print(kruskal.test(logLMA ~ Site, 
                   data = leaf_traits,
                   na.action = na.omit))

# LMA by Elevation_m
print(kruskal.test(logLMA ~ Elevation_m, 
                   data = leaf_traits,
                   na.action = na.omit))

# Toughness by Site
print(kruskal.test(logLPS ~ Site, 
                   data = leaf_traits,
                   na.action = na.omit))

# Toughness by Elevation_m
print(kruskal.test(logLPS ~ Elevation_m, 
                   data = leaf_traits,
                   na.action = na.omit))

# Thickness by Site
print(kruskal.test(logLT ~ Site, 
                   data = leaf_traits,
                   na.action = na.omit))

# Thickness by Elevation_m
print(kruskal.test(logLT ~ Elevation_m, 
                   data = leaf_traits,
                   na.action = na.omit))

# ACI by Site
print(kruskal.test(logACI ~ Site, 
                   data = leaf_traits,
                   na.action = na.omit))

# ACI by Elevation_m
print(kruskal.test(logACI ~ Elevation_m, 
                   data = leaf_traits,
                   na.action = na.omit))



#Post-Hoc tests
TukeyHSD(two.way, which = "Species")
pairwise.wilcox.test(imagej1$logLBI, g = imagej1$Site)
pairwise.wilcox.test(imagej1$logLBI, g = imagej1$Elevation_m)
pairwise.wilcox.test(imagej1$logLBI, g = imagej1$Genotype)
```

# Figures

### Leaf traits

```{r, correlations}
#Barplots with microeco
# Quick addition trais log transformed
ps_clean_3@sam_data <- plant_traits |>
  filter(Unique_ID %in% names_list) |>
  select(c(1:12, 15:20)) |>
  sample_data()

micro_psclean <- phyloseq2meco(ps_clean_3) # First convert phyloseq to meco

t4 <- trans_env$new(dataset = micro_psclean, env_cols = c(5,14:18))

t4gg <- t4$cal_autocor(group = "Species", upper = list(continuous = GGally::wrap("cor", method= "spearman"))) + 
  theme(
    legend.title = element_text(face = "bold"),
         strip.text = element_text(face = "bold", size = 12),
         panel.border = element_rect(linetype = "blank", fill = NA)) +
  scale_fill_manual(values = met.brewer("Isfahan2", n = 3, type = "discrete", direction = c(-1))) +
  scale_color_manual(values = met.brewer("Isfahan2", n = 3, type = "discrete", direction = c(-1)))

t4gg
#ggplot2::ggsave(file.path(path, "figures/supp_fig1.png") , plot = t4gg, dpi=300, units=c("mm"), width=300, height=300)
```

It looks like logLPS and logLMA are highly correlated globally and per species. The only traits not correlated are logLT and logLBI. Fot further analyses like dbRDA I will use logACI, logLBI, and logLT as part of the initial model.

```{r, themes}
#ggplot themes
# Theme for leaf trait and diversity plots: discrete
theme_lfspp_discrete <-      theme_classic(base_size = 16) +
  theme(legend.title = element_text(face = "bold"),
        strip.text = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        legend.text = element_markdown(size = 12), #Make legend text italic
        axis.text.x = element_blank())

# Theme for leaf trait plots: continuous
theme_lfspp_continuous <- theme_classic(base_size = 16) +
  theme(legend.title = element_text(face = "bold"),
        panel.border = element_rect(linetype = "blank", fill = NA),
        legend.text = element_markdown(size = 12), #Make legend text italic
        axis.text.x = element_text(size = 14),
        legend.position = "bottom")

# Theme for species by diversity  plots: discrete
theme_sppdiv_discrete <-    theme_classic(base_size = 16) +
   theme(legend.title = element_text(face = "bold"),
         strip.text = element_text(face = "italic", size = 14),
         panel.border = element_rect(linetype = "blank", fill = NA),
         legend.text = element_text(face = "italic", size = 12), #Make legend text italic
         axis.text.x.bottom = element_blank(),
         axis.title.x = element_blank())

# Theme for elevation diversity  plots: continuous
theme_elevdiv_discrete <-    theme_classic(base_size = 16) +
   theme(legend.title = element_text(face = "bold"),
         strip.text = element_text(face = "italic", size = 14),
         panel.border = element_rect(linetype = "blank", fill = NA),
         axis.text.x.bottom = element_blank(),
         axis.title.x = element_blank())

# Theme for leaf trait and diversity  plots: continuous
theme_lfdiv_continuous <- theme_classic(base_size = 16) +
   theme(legend.title = element_text(face = "bold"),
         strip.text = element_text(face = "bold.italic", size = 14),
         panel.border = element_rect(linetype = "blank", fill = NA),
         legend.text = element_markdown(size = 14), #Make legend text italic
         axis.text.x = element_text(size = 14))
```

#### LMA

```{r, lma_elevation}
#| echo: false
#| eval: true
#| tidy: true
#| label: lma_elevation

########## Labels ###########
#Legend title label
legend_title <- "Species"
# Species labels
labels_list <- c("M. laciniatus", "M. nasutus", "M. guttatus")
names(labels_list) <- c("L", "N", "G")
#############################

#ggpubr package used for comparisons tests
lma_compare_means <- compare_means(logLMA ~ Species,
         data = leaf_traits_noB,
         group.by = "Elevation_cat",
         method = "wilcox.test",
         p.adjust.method = "BH",
  paired = FALSE,
  alternative = "two.sided", 
  mu = 0, 
  var.equal = FALSE,
  conf.level = 0.95)

#lma_compare_means
#Report with `compare_means` because it is easier to plot with `ggpubr` package.

#Error bars for plots 
errbar_lims <- group_by(leaf_traits_noB, Site) |> 
              summarize(mean = mean(logLMA), se = sd(logLMA)/sqrt(n()), 
                        upper = mean+(2*se), lower = mean-(2*se))

#By Site discrete comparison
lma <- ggplot(leaf_traits_noB, aes(y = logLMA, x = Species)) +
  geom_violin(aes(fill = Species)) +
  geom_crossbar(stat = "summary",
                fun = mean,
                fun.max = mean,
                fun.min = mean,
                fatten = 1.5, width = 0.8) +
  geom_point(color = "black", alpha = 0.2,
             size = 1.7, 
             position = position_jitter(w = 0.05))  +
  scale_fill_manual(labels =c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*'),
                    values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  theme_lfspp_discrete +
  labs(y = "log10[Leaf Mass per Area (LMA) (mg/mm)]", x = "") +
  stat_compare_means(comparisons = my_comparisons,
                     method = "wilcox.test",
                     #label.y = c(0.4, 0.6, 1),
                     label = "p.signif") +
  facet_wrap(~Elevation_cat)

lma

#ggsave(filename = file.path(path, "figures/lma_violin.png"), plot = lma, dpi=300, units=c("mm"), width=300, height=150)

# By Elevation continuous comparison
# Linear model summary
summary(lm(logLMA ~ Elevation_m, data = leaf_traits_noB |>
             filter(!logLMA == "-Inf"), na.action = na.omit)) # Remove -Inf values
elev_lma_p <- format.p(cor.test(leaf_traits_noB$logLMA, leaf_traits_noB$Elevation_m, na.action = na.omit)$p.value) # This is just to make the p-value nicer. 

# logLMA by Elevation
lma_cont <- ggplot(leaf_traits_noB, aes(y = logLMA, x = Elevation_m)) +
  geom_jitter(aes(color = Species), alpha = 0.6,
             size = 2.5) +
  geom_smooth(method = lm, se = TRUE, level = 0.95, na.rm = F, color = "black") + 
  geom_smooth(aes(color = Species), method = lm, se = FALSE, na.rm = F) +
  stat_regline_equation(aes(label = paste(#..eq.label.., 
                                          ..adj.rr.label..,
                                          sprintf("italic('p')~'%s'", elev_lma_p), 
                                          sep = "~~~~")), size = rel(4), color = "black") +
  scale_color_manual(labels =c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*'),
                    values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  theme_lfspp_continuous +
  labs(y = "log10[Leaf Mass per Area (LMA) (mg/mm)]", x = "Elevation (m.a.s.l.)") +
  scale_y_continuous(expand = c(0.07, 0.07)) 

lma_cont
#ggsave(filename = file.path(path, "figures/lma_elev.png"), plot = logLMA_elev, dpi=300, units=c("mm"), width=300, height=150)

# Joining plots
lma_elevation <- ggarrange(lma, lma_cont, ncol = 1, nrow = 2, 
                           common.legend = TRUE, 
                           legend = "bottom",
                           labels = c("A", "B"),
                           heights = c(1, 1))

lma_elevation

#ggsave(filename = file.path(path, "figures/supp_fig1.png"), plot = lma_elevation, dpi=300, units=c("mm"), width=300, height=250)
```

#### ACI

```{r, aci_elevation}
#| echo: false
#| eval: true
#| tidy: true
#| label: aci_elevation

#ggpubr package used for comparisons tests
aci_compare_means <- compare_means(logACI ~ Species,
         data = leaf_traits_noB,
         group.by = "Elevation_cat",
         method = "wilcox.test",
         p.adjust.method = "BH",
  paired = FALSE,
  alternative = "two.sided", 
  mu = 0, 
  var.equal = FALSE,
  conf.level = 0.95)

#aci_compare_means
#Roughly the same outcome as pairwise_t_test.

#Report with `compare_means` because it is easier to plot with `ggpubr` package.
errbar_lims <- group_by(leaf_traits_noB, Species) |> 
              summarize(mean = mean(logACI), se = sd(logACI)/sqrt(n()), 
                        upper = mean + (2*se), lower = mean - (2*se))

#Comparisons
my_comparisons <- list(c("N", "L"), c("N", "G"), c("L", "G"))


aci <- ggplot(leaf_traits_noB, aes(y = logACI, x = Species)) +
  geom_violin(aes(fill = Species)) +
  geom_crossbar(stat="summary",
                fun = mean,
                fun.max = mean,
                fun.min = mean,
                fatten = 1.5, width = 0.8) +
  geom_point(color="black", alpha = 0.2,
             size=1.7, 
             position = position_jitter(w = 0.05))  +
  scale_fill_manual(labels=c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*'),
                    values= met.brewer("Isfahan2", n = 4, type = "discrete", direction = -1)) +
  theme_lfspp_discrete +
  labs(y = expression(paste("log[ACI (% ", italic("A") [lambda]," at 931 nm / % ", italic("A") [lambda]," at 530 nm)]")), x = "") +
  stat_compare_means(comparisons = my_comparisons,
                     method = "wilcox.test",
                     #label.y = c(0.4, 0.6, 1),
                     label = "p.signif") +
  facet_wrap(~Elevation_cat)

aci
#ggsave(filename = file.path(path, "figures/aci_violin.png"), plot = aci, dpi=300, units=c("mm"), width=300, height=150)

# By Elevation continuous comparison
# Linear model summary
summary(lm(logACI~ Elevation_m, data = leaf_traits_noB, na.action = na.omit))
elev_aci_p <- format.p(cor.test(leaf_traits_noB$logACI, leaf_traits_noB$Elevation_m, na.action = na.omit)$p.value) # This is just to make the p-value nicer. 

# logACI by Elevation
aci_cont <- ggplot(leaf_traits_noB, aes(y = logACI, x = Elevation_m)) +
  geom_jitter(aes(color = Species), alpha = 0.6,
             size = 2.5)  +
  geom_smooth(method = lm, se = TRUE, level = 0.95, na.rm = F, color = "black") + 
  geom_smooth(aes(color = Species), method = lm, se = FALSE, na.rm = F) +
  stat_regline_equation(aes(label = paste(#..eq.label.., 
                                          ..adj.rr.label..,
                                          sprintf("italic('p')~'%s'", elev_aci_p), 
                                          sep = "~~~~")), size = rel(4), color = "black") +
  scale_color_manual(labels =c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*'),
                    values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  theme_lfspp_continuous +
 labs(y = expression(paste("log[ACI (% ", italic("A") [lambda]," at 931 nm / % ", italic("A") [lambda]," at 530 nm)]")), x = "Elevation (m.a.s.l.)") +
  scale_y_continuous(expand = c(0.07, 0.07)) 

aci_cont
#ggsave(filename = file.path(path, "figures/aci_elev.png"), plot = aci_cont, dpi=300, units=c("mm"), width=300, height=150)

# Joining plots
aci_elevation <- ggarrange(aci, aci_cont, ncol = 1, nrow = 2, 
                           common.legend = TRUE, 
                           legend = "bottom",
                           labels = c("A", "B"),
                           heights = c(1, 1))

aci_elevation

#ggsave(filename = file.path(path, "figures/supp_fig2.png"), plot = aci_elevation, dpi=300, units=c("mm"), width=300, height=250)
```

#### LBI

```{r, lbi_elevation}
#| echo: false
#| eval: true
#| tidy: true
#| label: lbi_elevation

#ggpubr package used for comparisons tests
lbi_compare_means <- compare_means(logLBI ~ Species,
         data = leaf_traits_noB,
         group.by = "Elevation_cat",
         method = "wilcox.test",
         p.adjust.method = "BH",
  paired = FALSE,
  alternative = "two.sided", 
  mu = 0, 
  var.equal = FALSE,
  conf.level = 0.95)

#lbi_compare_means


#Roughly the same outcome as pairwise_t_test.

#Report with `compare_means` because it is easier to plot with `ggpubr` package.
errbar_lims <- group_by(leaf_traits_noB, Species) |> 
              summarize(mean = mean(logLBI), se = sd(logLBI)/sqrt(n()), 
                        upper = mean + (2*se), lower = mean - (2*se))

#Comparisons
my_comparisons <- list(c("N", "L"), c("N", "G"), c("L", "G"))

lbi <- ggplot(leaf_traits_noB, aes(y = logLBI, x = Species)) +
  geom_violin(aes(fill = Species)) +
  #geom_boxplot(width = 0.3, color = "grey30", alpha = 0.2) +
  geom_crossbar(stat = "summary",
                fun = mean,
                fun.max = mean,
                fun.min = mean,
                fatten = 1.5, width = 0.8) +
  geom_point(color = "black", alpha = 0.2,
             size = 1.7,
             position = position_jitter(w = 0.05))  +
  scale_fill_manual(labels =c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*'),
                    values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  theme_lfspp_discrete +
  labs(y = "log10[LBI (convex_hull - true_area]/convex_hull)]", x = "") +
  stat_compare_means(comparisons = my_comparisons,
                     method = "wilcox.test",
                     #label.y = c(0.4, 0.6, 1),
                     label = "p.signif") +
   facet_wrap(~Elevation_cat)
 
lbi
#ggsave(filename = file.path(path, "figures/lbi_violin.png"), plot = lbi, dpi=300, units=c("mm"), width=300, height=150)

# By Elevation continuous comparison
# Linear model summary
summary(lm(logLBI~ Elevation_m, data = leaf_traits_noB, na.action = na.omit))
elev_lbi_p <- format.p(cor.test(leaf_traits_noB$logLBI, leaf_traits_noB$Elevation_m, na.action = na.omit)$p.value) # This is just to make the p-value nicer. 

# logLBI by Elevation
lbi_cont <- ggplot(leaf_traits_noB, aes(y = logLBI, x = Elevation_m)) +
  geom_jitter(aes(color = Species), alpha = 0.6,
             size = 2.5)  +
  geom_smooth(method = lm, se = TRUE, level = 0.95, na.rm = F, color = "black") + 
  geom_smooth(aes(color = Species), method = lm, se = FALSE, na.rm = F) +
  stat_regline_equation(aes(label = paste(#..eq.label.., 
                                          ..adj.rr.label..,
                                          sprintf("italic('p')~'%s'", elev_lbi_p), 
                                          sep = "~~~~")), size = rel(4), color = "black") +
  scale_color_manual(labels =c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*'),
                    values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  theme_lfspp_continuous +
  labs(y = "log10[LBI (convex_hull - true_area]/convex_hull)]", x = "Elevation (m.a.s.l.)") +
  scale_y_continuous(expand = c(0.07, 0.07)) 

lbi_cont
#ggsave(filename = file.path(path, "figures/lbi_elev.png"), plot = lbi_cont, dpi=300, units=c("mm"), width=300, height=150)

# Joining plots
lbi_elevation <- ggarrange(lbi, lbi_cont, ncol = 1, nrow = 2, 
                           common.legend = TRUE, 
                           legend = "bottom",
                           labels = c("A", "B"),
                           heights = c(1, 1))

lbi_elevation

#ggsave(filename = file.path(path, "figures/supp_fig3.png"), plot = lbi_elevation, dpi=300, units=c("mm"), width=300, height=250)
```

#### Toughness

```{r, lps_elevation}
#| echo: false
#| eval: true
#| tidy: true
#| label: lps_elevation

#ggpubr package used for comparisons tests
lps_compare_means <- compare_means(logLPS ~ Species,
         data = leaf_traits_noB,
         group.by = "Elevation_cat",
         method = "wilcox.test",
         p.adjust.method = "BH",
  paired = FALSE,
  alternative = "two.sided", 
  mu = 0, 
  var.equal = FALSE,
  conf.level = 0.95)

#lps_compare_means

#Report with `compare_means` because it is easier to plot with `ggpubr` package.
errbar_lims <- group_by(leaf_traits_noB, Species) |> 
              summarize(mean = mean(logLPS), se = sd(logLPS)/sqrt(n()), 
                        upper = mean + (2*se), lower = mean - (2*se))

#Comparisons
my_comparisons <- list(c("N", "L"), c("N", "G"), c("L", "G"))

lps <- ggplot(leaf_traits_noB, aes(y = logLPS, x = Species)) +
  geom_violin(aes(fill = Species)) +
  #geom_boxplot(width = 0.3, color = "grey30", alpha = 0.2) +
  geom_crossbar(stat = "summary",
                fun = mean,
                fun.max = mean,
                fun.min = mean,
                fatten = 1.5, width = 0.8) +
  geom_point(color = "black", alpha = 0.2,
             size = 1.7,
             position = position_jitter(w = 0.05))  +
  scale_fill_manual(labels =c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*'),
                    values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  scale_color_manual(aes(color = "black")) +
  theme_lfspp_discrete +
  labs(y = expression(paste("Leaf punch strength (N mm","^-1)")), x = "") +
  #scale_x_discrete(labels = c('M. laciniatus', 'M. nasutus', 'M. guttatus')) +
  stat_compare_means(comparisons = my_comparisons,
                     method = "wilcox.test",
                     #label.y = c(0.4, 0.6, 1),
                     label = "p.signif") +
   facet_wrap(~Elevation_cat)
 

lps
#ggsave(filename = file.path(path, "figures/lps_violin.png"), plot = lps, dpi=300, units=c("mm"), width=300, height=150)

# By Elevation continuous comparison
# Linear model summary
summary(lm(logLPS ~ Elevation_m, data = leaf_traits_noB, na.action = na.omit))
elev_lps_p <- format.p(cor.test(leaf_traits_noB$logLPS, leaf_traits_noB$Elevation_m, na.action = na.omit)$p.value) # This is just to make the p-value nicer. 

# logLPS by Elevation
lps_cont <- ggplot(leaf_traits_noB, aes(y = logLPS, x = Elevation_m)) +
  geom_jitter(aes(color = Species), alpha = 0.6,
             size = 2.5)  +
  geom_smooth(method = lm, se = TRUE, level = 0.95, na.rm = F, color = "black") + 
  geom_smooth(aes(color = Species), method = lm, se = FALSE, na.rm = F) +
  stat_regline_equation(aes(label = paste(#..eq.label.., 
                                          ..adj.rr.label..,
                                          sprintf("italic('p')~'%s'", elev_lps_p), 
                                          sep = "~~~~")), size = rel(4), color = "black") +
  scale_color_manual(labels =c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*'),
                    values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  theme_lfspp_continuous +
  labs(y = expression(paste("Leaf punch strength (N mm","^-1)")), x = "Elevation (m.a.s.l.)") +
  scale_y_continuous(expand = c(0.07, 0.07)) 

lps_cont
#ggsave(filename = file.path(path, "figures/lps_elev.png"), plot = lps_cont, dpi=300, units=c("mm"), width=300, height=150)

# Joining plots
lps_elevation <- ggarrange(lps, lps_cont, ncol = 1, nrow = 2, 
                           common.legend = TRUE, 
                           legend = "bottom",
                           labels = c("A", "B"),
                           heights = c(1, 1))

lps_elevation

#ggsave(filename = file.path(path, "figures/supp_fig4.png"), plot = lps_elevation, dpi=300, units=c("mm"), width=300, height=250)
```

#### Thickness

```{r, lt_elevation}
#| echo: false
#| eval: true
#| tidy: true
#| label: lt_violin

#ggpubr package used for comparisons tests
lt_compare_means <- compare_means(logLT ~ Species,
         data = leaf_traits_noB,
         group.by = "Elevation_cat",
         method = "wilcox.test",
         p.adjust.method = "BH",
  paired = FALSE,
  alternative = "two.sided", 
  mu = 0, 
  var.equal = FALSE,
  conf.level = 0.95)

lt_compare_means
#Roughly the same outcome as pairwise_t_test.

#Report with `compare_means` because it is easier to plot with `ggpubr` package.
errbar_lims <- group_by(leaf_traits_noB, Species) |> 
              summarize(mean = mean(logLT), se = sd(logLT)/sqrt(n()), 
                        upper = mean + (2*se), lower = mean - (2*se))

#Comparisons
my_comparisons <- list(c("N", "L"), c("N", "G"), c("L", "G"))

lt <- ggplot(leaf_traits_noB, aes(y= logLT, x = Species)) +
  geom_violin(aes(fill = Species)) +
  #geom_boxplot(width = 0.3, color = "grey30", alpha = 0.2) +
  geom_crossbar(stat = "summary",
                fun = mean,
                fun.max = mean,
                fun.min = mean,
                fatten = 1.5, width = 0.8) +
  geom_point(color = "black", alpha = 0.2,
             size = 1.7,
             position = position_jitter(w = 0.05))  +
  scale_fill_manual(labels =c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*'),
                    values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  scale_color_manual(aes(color = "black")) +
  theme_lfspp_discrete +
  labs(y = expression(paste("Leaf thickness (",mu,"m)")), x = "") +
  scale_x_discrete(labels = c('M. laciniatus', 'M. nasutus', 'M. guttatus')) +
  stat_compare_means(comparisons = my_comparisons,
                     method = "wilcox.test",
                     #label.y = c(0.4, 0.6, 1),
                     label = "p.signif") +
   facet_wrap(~Elevation_cat)
 
lt
#ggsave(filename = file.path(path, "figures/lt_violin.png"), plot = lt, dpi=300, units=c("mm"), width=300, height=150)

# By Elevation continuous comparison
# Linear model summary
summary(lm(logLT ~ Elevation_m, data = leaf_traits_noB, na.action = na.omit))
elev_lt_p <- format.p(cor.test(leaf_traits_noB$logLT, leaf_traits_noB$Elevation_m, na.action = na.omit)$p.value) # This is just to make the p-value nicer. 

# logLT by Elevation
lt_cont <- ggplot(leaf_traits_noB, aes(y = logLT, x = Elevation_m)) +
  geom_jitter(aes(color = Species), alpha = 0.6,
             size = 2.5)  +
  geom_smooth(method = lm, se = TRUE, level = 0.95, na.rm = F, color = "black") + 
  geom_smooth(aes(color = Species), method = lm, se = FALSE, na.rm = F) +
  stat_regline_equation(aes(label = paste(#..eq.label.., 
                                          ..adj.rr.label..,
                                          sprintf("italic('p')~'%s'", elev_lt_p), 
                                          sep = "~~~~")), size = rel(4), color = "black") +
  scale_color_manual(labels =c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*'),
                    values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  theme_lfspp_continuous +
  labs(y = expression(paste("Leaf thickness (",mu,"m)")), x = "Elevation (m.a.s.l.)") +
  scale_y_continuous(expand = c(0.07, 0.07)) 

lt_cont
#ggsave(filename = file.path(path, "figures/lps_elev.png"), plot = lps_cont, dpi=300, units=c("mm"), width=300, height=150)

# Joining plots
lt_elevation <- ggarrange(lt, lt_cont, ncol = 1, nrow = 2, 
                           common.legend = TRUE, 
                           legend = "bottom",
                           labels = c("A", "B"),
                           heights = c(1, 1))
lt_elevation
#ggsave(filename = file.path(path, "figures/supp_fig5.png"), plot = lt_elevation, dpi=300, units=c("mm"), width=300, height=250)
```

#### Multiple plots together

```{r}
# Multiples plots together
#LMA and ACI
arrange <- ggarrange(lma, aci, lbi, lps, lt,
                     nrow = 2, 
                     ncol = 3, 
                     common.legend = TRUE, 
                     legend="right")
arrange

ggsave(filename = file.path(path, "Plots", "/lma_aci_evo23.png"), plot = arrange, dpi=300, units=c("mm"), width=300, height=150)

#LBI
ggsave(filename = file.path(path, "Plots", "/lbi_evo23.png"), plot = lbi, dpi=300, units=c("mm"), width=150, height=150)

#Toughness and Thickness
arrange2 <- ggarrange( thg, thk, nrow = 1, ncol=2, common.legend = TRUE, legend="right")
arrange2

ggsave(filename = file.path(path, "Plots", "/thg_thk_evo23.png"), plot = arrange2, dpi=300, units=c("mm"), width=300, height=150)


# Adding caption
ant_caption <- "*All individuals per tree species included (n = 210)"
ant_arranged_with_caption <- annotate_figure(ant_arranged, bottom = text_grob(ant_caption), fig.lab.pos = "bottom.right", fig.lab.size = 6)

ant_arranged_with_caption
```

#### PCA

```{r, PCA}
#| echo: false
#| eval: true
#| tidy: true
#| fig-width: 5
#| fig-height: 5
#| label: pca
#| fig-cap: "PCA of leaf traits by species."

# PCA using covariates to explain species richness/abundance ####
data.pca <- leaf_traits_noB |>
  na.omit() |>
  select(c(20:24)) #Selecting only the log-transformed leaf trait columns. I use the log transformed data due to our findings of non-normality in the data. See this post for a hot take: https://stats.stackexchange.com/questions/164381/why-log-transforming-the-data-before-performing-principal-component-analysis

leaf_traits.pca <- na.omit(leaf_traits_noB) 


###Run this to create pca with prcomp function
pca <- prcomp(data.pca, scale = TRUE)
pca$rotation=-pca$rotation #  Flips the directions of the principal components and the scores for interpretative consistency.
pca$x=-pca$x

#Checking the PCA
plot(pca,type = "lines")
biplot(pca) # Base type PCA

# PCA using autoplot() and prcomp()and modifying with ggplot syntax ####
pca_auto <- autoplot((pca), data = data.frame(leaf_traits.pca), # For some reason this functions require data to be data= data.frame()
         alpha = 0, #Setting alpha to zero render the automatic circle point null.Manipulate shapes with geom_point(). 
         loadings = TRUE,loadings.colour = "black",
         loadings.label = TRUE, loadings.label.colour="black",
         loadings.label.size = 4, size = 7, 
         loadings.label.vjust = 0, 
         loadings.label.hjust = -0.15) + 
  geom_point(aes(fill = Species, color = Species), alpha = 0.5, size = 3) +
  geom_hline(yintercept = 0, colour = "gray45") +
  geom_vline(xintercept = 0, colour = "gray45") +
    scale_fill_manual(labels=c("*M. laciniatus*", "*M. nasutus*", "*M. guttatus*"), 
                    values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  scale_color_manual(labels = c("*M. laciniatus*", "*M. nasutus*", "*M. guttatus*"),
                     values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  stat_ellipse(aes(color = Species), 
               geom = "path", 
               size = 1.3, 
               position = "identity", 
               type = "t", 
               linetype = 1, 
               level = 0.95, 
               segments = 51, na.rm = TRUE, show.legend = NA, inherit.aes = TRUE) +
  #scale_x_continuous(expand = c(0.0, -0.09)) +
  theme_classic(base_size = 12) +
  theme(legend.text = element_markdown(),
        legend.position = "bottom",
        legend.title = element_text(face = "bold")) 
  # labs(caption = expression("ACI = anthocyanins, LPS = leaf punch strength, LMA = leaf mass per area, LT = leaf thickness. LBI = Leaf lobe index. All leaf replicates per species ("~ italic("n") ~ "= 501)."))


pca_auto$layers <- c(pca_auto$layers, pca_auto$layers[[2]], pca_auto$layers[[3]]) # This adds/copies layers 2-3 and overlays them. It makes the arrows be on top of the points. There must be a better ways of doing this.

pca_auto

#ggsave(filename = file.path(path, "figures/pca.png"), plot = pca_auto, dpi=300, units=c("mm"), width=150, height=150)
```

# Community Diversity

Here we are going to explore the relationship between elevation and FEF community composition through richness and species diversity. I have already calculated Hill numbers in \[Cleaning and Shaping data\]. He we create a dissimilarity matrix and calculate the distance between samples. I remove *M. bicolor* (species "B") from the analysis (see \[Cleaning and Shaping data\] for more details). Here we used a classic data frame that stems from `ps_clean_3` object. The matrix calculations can also be achieved using the phyloseq friendly packages: `microbiome`, `metagMisc` and `mirlyn`. First let's look as summary information from our phyloseq object (see also `mim2_bioinformatics.qmd`).

```{r, summary_info}
# How many ASVs per Phyla and reads per sample are there after decontamination?
# Previous exploration of the data is in `mim2_bioinformatics.qmd`

readcount(ps_clean_3) #Read count
phyloseq_summary(ps_clean_3, more_stats = F, long = F) # metagMisc overall summary
summarize_phyloseq(ps_clean_3) #Microbiome package summary

# How many samples with ASVs per phyla are there AFTER decontamination?
percent_phyla_clean <- phyloseq_ntaxa_by_tax(
  ps_clean_3,
  TaxRank = "Phylum",
  relative = F,
  add_meta_data = F
) |>
  as.data.frame() |>
  mutate(sum = sum(N.OTU)) |>
  group_by(Phylum) |>
  summarise(occurance_in_samples = n())# Count the number of ASV per phylum


# Coverage
cover_chao <- phyloseq_coverage(ps_clean_3, correct_singletons = T) #Coverage: Good-Turing frequency estimation (Chiu, Chao 2016)


# Prevalence plot
phyloseq_prevalence_plot(
  ps_clean_3,
  prev.trh = 0.5,
  taxcolor = "Phylum",
  facet = TRUE,
  point_alpha = 0.7,
  showplot = T
)

# Average relative ASVs per host species
ps_average <- phyloseq_average(
  ps_clean_3,
  avg_type = "arithmetic",
  acomp_zero_impute = NULL,
  aldex_samples = 157,
  aldex_denom = "all",
  group = "Species",
  drop_group_zero = TRUE,
  verbose = TRUE,
  progress = "text",
)

# Core ASV abundance
core_abundance(
  ps_clean_3@otu_table,
  detection = 0.1/100,
  prevalence = 50/100,
  include.lowest = FALSE
)

# Rare ASVs
rare_abundance(
  ps_clean_3@otu_table,
  detection = 0.1/100,
  prevalence = 50/100,
  include.lowest = FALSE
)
sample_names(ps_clean_3)
# Core taxa
core_tax <- core_members(ps_clean_3, detection = 0.1/100, prevalence = 50/100, include.lowest = FALSE)

# Rare taxa
rare_tax <- rare_members(ps_clean_3, detection = 0.1/100, prevalence = 50/100, include.lowest = FALSE)
```

The core taxa members are *Vishniacozyma victoriae* (ASV_1), *Cladosporium herbanum* (ASV_2) and *Cladosporium* spp. (ASV_7). The rest of the ASVs (228) are rare. Now that we have a better idea of what is present in samples we can move on to the next steps.

# Sampling depth and effort

How to decide sampling depth for rarefaction?

Visual assessment of sampling depth.

```{r, sampling_depth}
# Reads per sample
names_list <- colnames(ps_clean_3@otu_table) #List of samples
reads <- readcount(ps_clean_3) |>  
  as.data.frame() |>
  rownames_to_column(var = "Unique_ID") |>
  rename(n_seqs = "readcount(ps_clean_3)") |>
  right_join(plant_traits, by = "Unique_ID") |>
  filter(Unique_ID %in% names_list) |>
  select(Unique_ID, Site, Species, n_seqs)

# Sum of reads per site per species
reads_sum <- reads |>
  group_by(Site, Species) |>
  filter(Unique_ID %in% names_list) |>
  summarise(n_seqs = sum(n_seqs)) 

# Visualizing the distribution of reads
ggplot(reads, aes(x = n_seqs)) +
  geom_histogram(binwidth = 10000, fill = "grey", color = "black") +
  coord_cartesian(xlim = c(0, 100000)) # Cut-off

ggplot(reads, aes(x = 1, y = n_seqs)) +
  geom_jitter() +
  scale_y_log10()

test <- reads |>
  arrange(n_seqs) |>
  filter(Unique_ID %in% names_list)

ggplot(test, aes(x = 1:nrow(test), y = n_seqs)) +
  geom_line() +
  coord_cartesian(ylim = c(0, 100000)) # Cut-off


# Arrange the samples to see where the big breaks in counts are. 
reads |>
         arrange(n_seqs) |>
  filter(Unique_ID %in% names_list)

#Good's coverage
cover_goods <- ps_melt |>
  select(Unique_ID, sample_Species, ASV, Abundance) |>
  group_by(Unique_ID) |>
  summarise(n_seqs = sum(Abundance),
            n_sing = sum(Abundance == 1),
            goods = 1 - (n_sing/n_seqs)) 
cover_goods|>
  filter(n_seqs > 750) |> #Filtering samples with more than f000 reads
  ggplot(aes(x= n_seqs,y = goods)) +
  geom_point() # Similar to `phyloseq_coverage` results above but here we know how it is calculated.
          
cover_goods |>
  filter(n_seqs > 750) |>
  arrange(goods)
```

From the summaries above and graphical evaluation we see that 1) the median read count is 9619 and 2) all the way to \~5000 reads the difference in jumps is \~250, the jump to 5000 is  500 counts. Good's coverage shows that we have only 5 samples that are below \~0.99 cover threshold. I believe that establishing a sampling depth of 5000 reads is a good compromise between the number of samples and the number of reads. I will use this depth for the rarefaction curves.

### Rarefaction and species accumulation curves

I am calculating some curves to see if we have enough sampling effort.

::: callout-note
Rarefaction is subject to debate, see [@mcmurdie2014] and [@cameron2021] for a discussion.
:::

```{r, rarefaction}
# Alpha diversity metrics
set.seed(123)
# Initial matrices, before rarefaction
# ASV abundance matrix
asv_matrix <- as.matrix(otu_table(ps_clean_3)) # Results in 231 x 157 matrix

# Vegan
# Rarefaction curve
vegan::rarecurve(t(asv_matrix), step=50, cex=0.5, xlab = "Sample Size", ylab = "Species", label = FALSE, tidy = FALSE) # rrarefy generates one randomly rarefied community data frame or vector of given sample size. 

# Species accumulation curve
accum_curve <- specaccum(t(asv_matrix), 
                         method = "random", 
                         permutations = 1000, 
                         cex = 0.5)

plot(accum_curve, col = "blue", ci = 1, pch = 16, main = "Species Accumulation Curve", xvar = "sites", xlab = "Number of Samples", ylab = "Number of ASVs")
accum_curve
```

It seems we sampled enough, based on the species accumulation curve. The rarefaction curve also shows that species richness is not necessarily increasing with greater sequencing depth. There seems to be a range of \~35 ASVs per \~50,000 reads. Other samples \>200,000 reads also have around 35 ASVs. With the rarefaction of the data set to a sequence depth of 5000 reads we are left with 86 samples. About have of our original sample number.

### Rarefaction strategy for alpha diversity

Initially, I played around with rarefying at a 750 reads and was left with 99 samples. This is a decent balance between sequence depth and breadth. I attempted to use the `mirlyn` package to calculate 100 rarefied data sets per sequence depth parameter (e.g. 500, 1000, 3000) but the resulting phyloseq object is a list of phyloseq objects. I can select one and run analyses, but what I wanted was to average the all the data sets. The issue with averaging is that it returns doubles not integers. It then makes calculations of dissimilarity matrices and other analyses difficult. The final object from the chunk above calculates an estimate of alpha diversity from rarefied data sets. The `phyloseq_mult_raref_div` function returns a list of data frames with the alpha diversity indices. The plan is to wrangle this output to and join with `plant_traits` data to calculate correlations and other analyses.

After some trying a couple of things and thought, I manipulated the `alphadiv_DF` to return a data frame with "shannon", "simpson", and "invsimpson" from the `vegan` package. The data frame has diversity measure calculated for each of the iterations of the rarefied data sets. It still contains the previous diversity measures calculated (non-rarefied) in the \[Cleaning and Shaping\] section. joined this data frame with the `plant_traits` data frame to calculate correlations and other analyses. The manipulation of the function was done in the `alpha_rfy.R` file. The function is called `alpha_rfy_DF`. I used ChatGPT to troubleshoot and write the function. It would have taken me a long time to figure out.

I decided I am going to take two approaches to selecting rarefied datasets for this study. First, rarefy the sequences and then randomize the resulting samples to select a smaller subset (\~90 samples). Second approach is to randomize the samples first and then rarefy the sequences from those samples. I will compare and select the method that has the greatest sequencing breadth. The selection of samples will be done using a vector of samples names, this is most important for the second method. The names are selected from the `ps_clean_3` phyloseq object and/or the `ps_clean_3_df` data frame.

```{mermaid}
%%| label: fig-model
%%| fig-cap: "Models for rarefaction strategy."
%%| file: "rarefy_workflow.mmd"

```

```{mermaid}
flowchart LR
  A[Hard edge] --> B(Round edge)
  B --> C{Decision}
  C --> D[Result one]
  C --> E[Result two]
```

Let me evaluate how many samples per site we have:

```{r, samples_per_site}
samples_per_site <- reads |>
  group_by(Site) |>
  summarise(n_samples = n()) |>
  arrange(desc(n_samples))
```

We have around 7-10 samples per site per species. Some site are lower because they were removed in previous filtering stages.

#### Method A: Rarefaction of sequences \> samples

```{r, rarefaction_sequence}
# Phyloseq friendly packages

# mirlyn package 
#750 reads
# pseq_rrfa <- mirl(ps_clean_3,
#                  libsize = 750,
#                  rep = 50,
#                  set.seed = 443,
#                  trimOTUs = FALSE,
#                  replace = FALSE,
#                  mc.cores = 4)

#saveRDS(pseq_rrfa, file = "clean_data/statistics/pseq_rrfa.rds") # Saving rarefied phyloseq object
pseq_rrfa <- readRDS("clean_data/statistics/pseq_rrfa.rds") # Loading rarefied phyloseq object

# Select sample names
seq_sample_names <- sample_names(pseq_rrfa[[1]]) # Sample names

# Randomize sample names wit custom functions
rand_matrix <- matrix(NA_character_, nrow = 95, ncol = 95)

set.seed(443)
for (i in 1:95) {
  rand_matrix[i, ] <- sample(seq_sample_names, 95, replace = FALSE)
}

rand_select <- function(mat) {
    j <- sample(seq_len(ncol(mat)), size=1)
    rand_matrix[, j, drop=TRUE]    ## (Use `drop=FALSE` to say "don't convert 1-column matrices to vectors")
}

# Select random sample column
set.seed(443)
random_samples <- rand_select(rand_matrix)

# This list will be used to select samples from the long pseq_rrfy1 object



# Functions `mirl` and `phyloseq_mult_raref`are practically the same. The difference is that `mirl` returns a list of phyloseq objects and `phyloseq_mult_raref` returns a single phyloseq object.

# metagMisc package
# set.seed(443) # Important to set seed for reproducibility
# pseq_rrf <- phyloseq_mult_raref(ps_clean_3,
#                                 SampSize = 1000,
#                                 iter = 1000,
#                                 replace = FALSE,
#                                 multithread = TRUE)

# This function will resample an ASV table such that all samples have the same library size. Resampling will be performed multiple times.

# alpha_pseq <- phyloseq_mult_raref_div(pseq_rrf, # Estimating alpha diversity from rarefied datasets
#                                       SampSize = 1000,
#                                       iter = 1000,
#                                       divindex = c("Observed", 
#                                                    "Shannon", 
#                                                    "Simpson", 
#                                                    "InvSimpson"),
#                                       parallel = TRUE,
#                                       verbose = TRUE)



###########################
#### Custom functions #####
###########################
#After playing around with these functions I decided to change the `alphadivDF()` function to return a data frame with the alpha diversity indices, similar to how `estimate_richness()` calculates, from rarefied data sets. 
# Data frame with alpha diversity indices calculated from rarefied data sets
source("functions/alpha_rfy.R")
plant_traits_MA <- alpha_rfy_DF(pseq_rrfa, diversity = c("shannon", "simpson", "invsimpson")) # Alpha diversity indices


# RAW Preview
ggplot(plant_traits_MA, aes(x = Elevation_cat, y = shannon_, color = Species)) +
  geom_boxplot(alpha = 0.3, size = 0.5) +
  facet_wrap(~Species) +
  theme_classic(base_size = 12)
```

Now let's clean it up, select the randomized subsamples, and start plotting.

##### Rarefied data frame Method A

```{r, rarefaction_output}
# Method A output
plant_traits_MA <- plant_traits_MA |>
  select(!c(11:12)) |> # Removing variables calculated before rarefactions
  relocate(Unique_ID, .before = Site) |># Moving Unique_ID to the front
  mutate(Unique_ID =  str_remove(Unique_ID, "^.*?(_|-)"),
         hill_1 = exp(shannon_)) |> # Observed column is equivalent to hill_0
  # Simpson index is (1-D) and InvSimpson (1/D) which is equivalent to hill_2
  filter(Unique_ID %in% random_samples) |># Selecting only samples from randomization
  rename(
    Observed = observed, 
    Shannon = shannon_,
    Simpson_1minusD = simpson_,
    hill_2 = invsimpson_
  ) |>
  relocate(Observed, .before = Shannon)# Renaming and relocating columns

#Saving rarefied data frame
#saveRDS(plant_traits_MA, file = "clean_data/statistics/plant_traits_MA.rds") # Saving rarefied data frame
#write.csv(plant_traits_MA, file = "clean_data/statistics/plant_traits_MA.csv") # Saving rarefied data frame as csv

#Loading rarefied data frame
#plant_traits_MA <- readRDS("clean_data/statistics/plant_traits_MA.rds") # Loading rarefied data frame
```

I now have a data frame with 95 samples with rarefied alpha diversity indices and plant traits. I will use this for downstream analyses.

#### Method B: Rarefaction of samples \> sequences

```{r, rarefaction_samples}
# Select random samples from 157 pool
# Reduce each site by 1. The is a total of 21 sites.

# Random selection
names_list <- colnames(ps_clean_3@otu_table) #List of samples

set.seed(443)
methodB_samples <- sample(names_list, 136, replace = FALSE)

# Rarefy selected samples
methodB_ps <- prune_samples(sample_names(ps_clean_3) %in% methodB_samples, ps_clean_3) # Selecting samples from randomization

pseq_rrfb <-  mirl(methodB_ps,
                  libsize = 750,
                  rep = 50,
                  set.seed = 443,
                  trimOTUs = FALSE,
                  replace = FALSE,
                  mc.cores = 4)


# Save 
#saveRDS(pseq_rrfb, file = "clean_data/statistics/pseq_rrfb.rds") # Saving rarefied phyloseq object

# Load
pseq_rrfb <- readRDS("clean_data/statistics/pseq_rrfb.rds") # Loading rarefied phyloseq object

# A total of 84 samples result from method B
final_names_methodB <- sample_names(pseq_rrfb[[1]]) # Sample names
```

#### Compare rarefaction and randomization methods

```{r, compare}
# Methods A
plant_traits_MA |>
  select(Unique_ID, Site, Elevation_cat,  Species) |>
  group_by(Elevation_cat) |>
  summarise(n = n()/50) # Number of samples per site per species/ 50 data sets

#Method B
plant_traits_MB |>
  select(Unique_ID, Site, Elevation_cat,  Species) |>
  group_by(Elevation_cat) |>
  summarise(n = n()/50) # Number of samples per species

#Descriptive stats
t.test(plant_traits_MA$Observed, plant_traits_MB$Observed) # Observed richness
t.test(plant_traits_MA$Shannon, plant_traits_MB$Shannon) # Shannon diversity
t.test(plant_traits_MA$Simpson_1minusD, plant_traits_MB$Simpson_1minusD) # Simpson diversity


# Good's coverage
reads_rrfa <- readcount(pseq_rrfa[[1]]) |>  #Unsing first phyloseq object to explore
  as.data.frame() |>
  rownames_to_column(var = "Unique_ID") |>
  rename(n_seqs = "readcount(ps_clean_3)") |>
  right_join(plant_traits, by = "Unique_ID") |>
  select(Unique_ID, Site, Species, n_seqs)

# Sum of reads per site per species
reads_sum <- reads |>
  group_by(Site, Species) |>
  filter(Unique_ID %in% names_list) |>
  summarise(n_seqs = sum(n_seqs)) 

#Observed richness comparison
ggplot()+
 geom_density(data = plant_traits_MA, aes(x = Observed, fill = Species), alpha = 0.5) + # must include argument label "data"
  geom_density(data = plant_traits_MB, aes(x = Observed, color = Species)) 


# Boxplot
ggplot() +
  geom_boxplot(data = plant_traits_MA, aes(x= Species, y = Shannon, fill = Species)) +
  geom_boxplot(data = plant_traits_MB, aes(x= Species, y = Shannon, color = "yellow"), alpha = 0.1) +
  theme_classic(base_size = 12) +
  labs(title = "Comparison of MA and MB", x = "Species", y = "Shannon") 

```

#### Sampling depth and effort conclusions:

For method A have a total of \~ 18-22 incdividual plants per elevation category, and 24 individual of *M. laciniatus*, 9 for *M. nasutus* and 28 for *M. guttatus*. for guttatus across all 50 rarefied datasets. Method B has 32 *M. laciniatus*, 15 *M. nasutus*, and 37 *M. guttatus*. Method B has 25-30 indivdual plants per elevation category a more balanced distribution of individuals per species. Density plots for observed richness show that the distribution of richness is similar between the two methods. Method B does capture better *M. nasutus*' richness better. Method B has better balanced between the species represented. Yes, it is less samples, but it has a better distribution of represent host species, due to maintaining more *M. nasutus* samples. Qualitatively they don't differ much. T-tests suggest no differences in observed richness, but significant differences in Shannon and Simpson diversity. **I will use method B for downstream analyses due to better balance of host species representation.**

#### 

```{r, rarefaction_outputB}
# Method B output
plant_traits_MB <- alpha_rfy_DF(pseq_rrfb, diversity = c("shannon", "simpson", "invsimpson")) # Alpha diversity indices


# Remaking like plants_traits
# Very much like in Cleaning and Shaping chunk
plant_traits_MB <- plant_traits_MB |>
  select(!c(12:13)) |> # Removing ImageJ measurments
  mutate(X = Unique_ID, # Copyin column to new column
    Unique_ID =  str_remove(Unique_ID, "^.*?(_|-)"),
         hill_1 = exp(shannon_), 
         logLBI = log10(LBI),
         logACI = log10(ACI),
         logLT = log10(LT),
         logLPS = log10(LPS),
         logLMA = log10(LMA)) |>
  relocate(X, Unique_ID, .before = Site) |># Moving Unique_ID to the front
  rename(
    Observed = observed, 
    Shannon = shannon_,
    Simpson_1minusD = simpson_,
    hill_2 = invsimpson_
  ) |>
  relocate(Observed, .before = Shannon)# Renaming and relocating columns

# Saving rarefied data frame
#saveRDS(plant_traits_MB, file = "clean_data/statistics/plant_traits_MB.rds") # Saving rarefied data frame
#write.csv(plant_traits_MB, file = "clean_data/statistics/plant_traits_MB.csv") # Saving rarefied data frame as csv

#Loading rarefied data frame
plant_traits_MB <- readRDS("clean_data/statistics/plant_traits_MB.rds") # Loading rarefied data frame.
```

::: callout-note
All analyses for alpha and beta diversity below are completed with `plant_traits_MB` data frame.
:::


### Exploring rarefied data set

```{r, rarefied_data}
#Mirl object to phyloseq
#Taking the mirl object from Method B (see Rarefied data frame Method B) and converting it to a phyloseq object
#Names of samples cleaned an filtered
final_names <- sample_names(pseq_rrfb[[1]]) # Names of samples)

rrfy_asv_table <- as.data.frame(t(rep_otu_df(pseq_rrfb))) |> # Rarefied counts
  rownames_to_column("X") |>
  mutate(Unique_ID =  X, # Copyin column to new column
         Unique_ID =  str_remove(Unique_ID, "^.*?(_|-)")) |>
  relocate(Unique_ID, .after = X) |>
  left_join(plant_traits, by = "Unique_ID")


#ASV table
ASV <- rrfy_asv_table |>
                   column_to_rownames(var = "X") |>
                 select(-c(1, 232:256))|>
                 as.matrix()
ASV <- otu_table(t(ASV), taxa_are_rows = TRUE)
taxa_names(ASV) #Should be ASV_#

#Taxonomixc table
TAXA <- read.csv(file.path(path,"clean_data/taxonomy/ASV_8450_phyloseq_nonsingletons_noB.csv")) # Taxonomic table
TAXA <- TAXA|>
  select(2:9) |>
  column_to_rownames(var = "ASV") |>
  as.matrix() |>
  tax_table()

# Sample data
SAMP <- rrfy_asv_table |>
  select(c(1:2, 234:257)) |>
  as.data.frame() |>
  column_to_rownames(var = "X") |>
  sample_data()

# Rarfefied phyloseq object
rarefied_phyloseq <- phyloseq(ASV, SAMP, TAXA)

#saveRDS(rarefied_phyloseq, file.path(path, "clean_data/statistics/rarefied_phyloseq.rds"))



# Rarefied summary 
# Core ASV abundance
core_abundance(
  rarefied_phyloseq@otu_table,
  detection = 0.1/100,
  prevalence = 50/100,
  include.lowest = FALSE
)

# Rare ASVs
rare_abundance(
 rarefied_phyloseq@otu_table,
  detection = 0.1/100,
  prevalence = 50/100,
  include.lowest = FALSE
)

# Core taxa
core_tax <- core_members(rarefied_phyloseq, detection = 0.1/100, prevalence = 50/100, include.lowest = FALSE)

# Rare taxa
rare_tax <- rare_members(rarefied_phyloseq, detection = 0.1/100, prevalence = 50/100, include.lowest = FALSE)

```


### Dissimilarity and geographic distance matrices

#### Rarefaction strategy for beta diversity

1.  Subset matrix to sample output from alpha diversity rarefaction
    1.  Method B
2.  Hellinger transformation of the ASV matrix and rarefaction
    1.  See here for a [brief discussion.](https://stats.stackexchange.com/questions/594876/should-i-use-hellinger-transformed-species-abundance-data-for-nmds-if-this-is)
    2.  @legendre2001
3.  Bray-Curtis dissimilarity matrix of mean from rarefied datasets.

##### Matrices

```{r, diss_matrix}
#| echo: false
#| eval: true
#| tidy: true
# Simple Matrix of 84 samples from Method B pipeline
asv_matrix <- otu_table(ps_clean_3) |> # ASV matrix
  as.data.frame() |>
  select(contains(final_names_methodB)) |> # Samples from method B randomization
  as.matrix()

#Hellinger transformation of matrices rarefied to 750 reads
# To be used for dbRDA and adonis2
rrfy_hell_matrix <- decostand(as.matrix(t(rep_otu_df(pseq_rrfb))), MARGIN = 1, method = "hellinger")

# Cleaning row names
rrfy_hell_matrix <- as.data.frame(rrfy_hell_matrix) |>
  rownames_to_column(var = "X") |>
  mutate(Unique_ID =  X, # Copyin column to new column 
         Unique_ID =  str_remove(Unique_ID, "^.*?(_|-)")) |>
  relocate(Unique_ID, .after = X) |>
  left_join(plant_traits, by = "Unique_ID")
  #t() # Transpose due to duplicate row names not allowed

# Save
saveRDS(rrfy_hell_matrix, file = "clean_data/statistics/rrfy_hell_matrix.rds") 

# Load
rrfy_hell_matrix <- readRDS("clean_data/statistics/rrfy_hell_matrix.rds")


# Mean Hellinger transformation of rarefied data sets
# For Mantel tests
set.seed(433)
asv_avgdist <- avgdist(t(asv_matrix),
                       sample = 750,
                       distfun = vegdist,
                       dmethod = "hellinger", #Transformation, later Bray_Curtis
                       meanfun = mean,
                       iterations = 50) |>
  as.matrix()

# Save
#saveRDS(asv_avgdist, file = "clean_data/statistics/asv_avgdist.rds") # Saving rarefied phyloseq object

# Load  
asv_avgdist <- readRDS("clean_data/statistics/asv_avgdist.rds") # Loading rarefied phyloseq object

# Rarefied data frame names
final_names_methodB <- colnames(asv_avgdist) # Rarefied data frame names from avgdist

# Checking if alpha and beta diversity rarefied objects are the same
test <- sample_data(pseq_rrfb[[1]]) |> # Rarefied phyloseq object
  rownames() 
  # arrange() |>
  # as.character()

# Check if the vectors are identical
identical(sort(test), sort(final_names_methodB)) # TRUE

# Adding column and rownames
rownames(asv_avgdist) <- final_names_methodB
colnames(asv_avgdist) <- final_names_methodB

# Geographical matrix
geo_distm <- distm(plant_traits |>
                      filter(Unique_ID %in% final_names_methodB) |>
                      column_to_rownames(var = "Unique_ID") |>
                      select(Longitude, Latitude), fun = distVincentyEllipsoid)
                      
# Adding column and rownames
rownames(geo_distm) <- rownames(final_names_methodB)
colnames(geo_distm) <- rownames(final_names_methodB)

# Save
saveRDS(geo_distm, file = "clean_data/statistics/geo_distm.rds") 

# Load
geo_distm <- readRDS("clean_data/statistics/geo_distm.rds")
```


#### Hill number plots

```{r, hill_numbers}
# Shannon Diversity or hill number 1
# Three main faceted plots come out of this chunk

########## Labels ###########
#Legend title label
legend_title <- "Species"
# Species labels
labels_list <- c("M. laciniatus", "M. nasutus", "M. guttatus")
names(labels_list) <- c("L", "N", "G")
#############################

#####################################################
#### Alpha diversity ####
#### Across elevation ####
#####################################################
# Hill number 0 
# Species richness or hill number 0

#Linear model summary
#summary(lm(Observed ~ Elevation_m, data = plant_traits_rf))
#richness_p <- format.p(cor.test(plant_traits$Observed, plant_traits$Elevation_m)$p.value) # This is just to make the p-value nicer. 
# Species labels
labels_list <- c("M. laciniatus", "M. nasutus", "M. guttatus")
names(labels_list) <- c("L", "N", "G")

# Plot
hill0_diversity <- ggplot(data = plant_traits_MB, 
                          aes(x = Elevation_m, y = Observed, color = Species)) +
   geom_jitter(aes(color = Species), 
               #stat = "summary",
               #fun = mean,
               size = 3, alpha = 0.3) + 
   #geom_smooth(method = lm, se = F) +
  geom_smooth(method = lm, se = T, level = 0.95, na.rm = F, color = "black") +
  stat_poly_eq(formula = y ~ x, color = "black",
               aes(label = paste(#..eq.label.., 
                 ..adj.rr.label.., #"~italic(p) ==",
                 ..p.value.label.., 
                 #signif(..p.value.., digits = 4),
                 sep = "*`,`~~")), 
               rr.digits = 2,
               p.digits = 3 ,
               parse = TRUE,
               label.x = "left",
               label.y= "top",
               vstep = 0.08) +
   scale_fill_manual(labels = c("*M. laciniatus*","*M. nasutus*", "*M. guttatus*"), 
                     values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) + 
   scale_color_manual(legend_title, labels = c("*M. laciniatus*", "*M. nasutus*", "*M. guttatus*"), 
                      values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) + 
   theme_lfdiv_continuous +
   labs(y =  "\U1D492 = 0", x = "", col = "") + 
   scale_y_continuous(expand = c(0.05, 0.05)) +
  scale_x_continuous(expand = c(0.05, 0.05)) +
  facet_wrap(~ Species) +
  guides(color = "none")        #To turn off color legend
  # annotate(geom = "text", x = 2100, y = 2.5, label = "p = 0.03", color = "black")
#annotate(geom="text", x=2100, y=50, label="p = 0.06", color = "black")

#hill0_diversity

#ggsave(filename = file.path(path, "figures/richness_elevation.png"), plot = hill0_diversity, dpi=300, units=c("mm"), width=250, height=150)

# Linear models per species
# Linear model summary
# M. laciniatus
#summary(lm(Observed ~ Elevation_m, data = plant_traits[plant_traits$Species == "L",]))
#Not significant

# M. nasutus
#summary(lm(Observed ~ Elevation_m, data = plant_traits[plant_traits$Species == "N",]))
#Not significant

# M. guttatus
#summary(lm(Observed~ Elevation_m, data = plant_traits[plant_traits$Species == "G",]))
#Not significant

# Hill number 1
# Shannon diversity or hill number 1
# Linear model summary
#summary(lm(Shannon ~ Elevation_m, data = plant_traits))
#elev_div_p <- format.p(cor.test(plant_traits$Shannon, plant_traits$Elevation_m)$p.value) # This is just to make the p-value nicer. 

# Plot
hill1_diversity <- ggplot(data = plant_traits_MB,
                          aes(x = Elevation_m, y = hill_1, color = Species)) +
   geom_jitter(aes(color = Species), 
               #stat = "summary",
               #fun = mean,
               size = 3, alpha = 0.3) + 
   geom_smooth(method = lm, se = F) + 
   geom_smooth(method = lm, se = T, level = 0.95, na.rm = F, color = "black") + 
  stat_poly_eq(formula = y ~ x, color = "black",
               aes(label = paste(#..eq.label.., 
                 ..adj.rr.label.., #"~italic(p) ==",
                 ..p.value.label.., 
                 #signif(..p.value.., digits = 4),
                 sep = "*`,`~~")), 
               rr.digits = 2,
               p.digits = 3 ,
               parse = TRUE,
               label.x = "left",
               label.y = "top",
               vstep = 0.08) +
   #scale_fill_manual(labels = c("*M. laciniatus*","*M. nasutus*", "*M. guttatus*"), 
                     #values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) + 
   scale_color_manual(legend_title,
                     values = met.brewer("Isfahan2", n = 4, type = "discrete", 
                                          direction = c(-1))) + 
  labs(y = "\U1D492 = 1", x = "", col = "") +
  scale_y_continuous(expand = c(0.05, 0.05)) +
  theme_lfdiv_continuous +
  theme(strip.text = element_blank()) +
  #facet_wrap(~ Species, labeller = labeller(Species = labels_list)) +
  facet_wrap(~ Species) +
  guides(color = "none")        #To turn off color legend

#hill1_diversity

#ggsave(filename = file.path(path, "figures/shannon_elevation.png"), plot = hill1_diversity, dpi=300, units=c("mm"), width=250, height=150)

# Linear models per species
# Linear model summary
# M. laciniatus
#summary(lm(hill_1 ~ Elevation_m, data = plant_traits[plant_traits$Species == "L",]))
#Not significant

# M. nasutus
#summary(lm(hill_1 ~ Elevation_m, data = plant_traits[plant_traits$Species == "N",]))
#Not significant

# M. guttatus
#summary(lm(hill_1 ~ Elevation_m, data = plant_traits[plant_traits$Species == "G",]))
#Not significant

# Hill number 2
# Inverse Simpson diversity or hill number 2
# Linear model summary
#summary(lm(hill_2 ~ Elevation_m, data = plant_traits))
#elev_div_p <- format.p(cor.test(plant_traits$Shannon, plant_traits$Elevation_m)$p.value) # This is just to make the p-value nicer. 

# Plot
hill2_diversity <- ggplot(data = plant_traits_MB, 
  aes(x = Elevation_m, y = hill_2, color = Species)) +
   geom_jitter(aes(color = Species), 
               #stat = "summary",
               #fun = mean,
               size = 3, alpha = 0.3) + 
   geom_smooth(method = lm, se = F) + 
   # stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = '~~~~'))) 
   geom_smooth(method = lm, se = T, level = 0.95, na.rm = F, color = "black") + 
  stat_poly_eq(formula = y ~ x, color = "black",
               aes(label = paste(#..eq.label.., 
                 ..adj.rr.label.., #"~italic(p) ==",
                 ..p.value.label.., 
                 #signif(..p.value.., digits = 4),
                 sep = "*`,`~~")), 
               rr.digits = 2,
               p.digits = 3 ,
               parse = TRUE,
               label.x = "left",
               label.y = "top",
               vstep = 0.08) +
   #scale_fill_manual(labels = c("*M. laciniatus*","*M. nasutus*", "*M. guttatus*"), 
                     #values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) + 
   scale_color_manual(legend_title, labels = c("*M. laciniatus*", "*M. nasutus*", "*M. guttatus*"), 
                     values = met.brewer("Isfahan2", n = 4, type = "discrete", 
                                          direction = c(-1))) + 
  labs(y = "\U1D492 = 2", x = "Elevation (m.a.s.l.)", col = "") +
  theme_lfdiv_continuous +
  theme(strip.text = element_blank()) +
  #facet_wrap(~ Species, labeller = labeller(Species = labels_list)) +
  facet_wrap(~ Species) +
  guides(color = "none")        #To turn off color legend

#hill2_diversity

#ggsave(filename = file.path(path, "figures/invsimpson_elevation.png"), plot = hill2_diversity, dpi=300, units=c("mm"), width=250, height=150)

# Linear models per species
# Linear model summary
# M. laciniatus
#summary(lm(hill_2 ~ Elevation_m, data = plant_traits[plant_traits$Species == "L",]))
#Not significant

# M. nasutus
#summary(lm(hill_2 ~ Elevation_m, data = plant_traits[plant_traits$Species == "N",]))
#Not significant

# M. guttatus
#summary(lm(hill_2 ~ Elevation_m, data = plant_traits[plant_traits$Species == "G",]))
#Not significant


###### Joined plots ######
hill_numbers <- ggarrange(hill0_diversity, hill1_diversity, hill2_diversity,
                          labels = c("A", "B", "C"),
                          nrow = 3, ncol = 1)

hill_numbers
#ggsave(filename = file.path(path, "figures/figure2.png"), plot = hill_numbers, dpi=300, units=c("mm"), width=300, height=275)

############################################
#### Alpha diversity ####
#### At the species level ####
############################################

labels_list <- c("M. laciniatus", "M. nasutus", "M. guttatus")
names(labels_list) <- c("L", "N", "G")

# Plot
hill0_species <- ggplot(data = plant_traits_MB, 
  aes(x = Species, y = Observed)) +
  geom_boxplot(aes(fill = Species)) +
  # geom_crossbar(stat="summary",
  #               fun = mean,
  #               fun.max = mean,
  #               fun.min = mean,
  #               fatten = 1.5, width = 0.8) +
  # geom_point(color="black", alpha = 0.2,
  #            size=1.7, 
  #            position = position_jitter(w = 0.05))  +
  scale_fill_manual(labels=c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*'),
                    values= met.brewer("Isfahan2", n = 4, type = "discrete", direction = -1)) +
  scale_color_manual(aes(color = "black")) +
  theme_sppdiv_discrete +
  labs(y =  "\U1D492 = 0", x = "", col = "") + 
  stat_compare_means(comparisons = my_comparisons,
                     method = "wilcox.test", 
                     label = "p.signif") 
  #guides(color = "none")        #To turn off color legend
  
hill0_species
# annotate(geom = "text", x = 2100, y = 2.5, label = "p = 0.03", color = "black")
#annotate(geom="text", x=2100, y=50, label="p = 0.06", color = "black")


# Hill number 1
# Shannon diversity or hill number 1
# Plot
hill1_species <- ggplot(data = plant_traits_MB, 
  aes(x = Species, y = hill_1)) +
  geom_boxplot(aes(fill = Species)) +
  # geom_crossbar(stat="summary",
  #               
  #               fun = mean,
  #               fun.max = mean,
  #               fun.min = mean,
  #               fatten = 1.5, width = 0.8) +
  # geom_point(color="black", alpha = 0.2,
  #            size=1.7, 
  #            position = position_jitter(w = 0.05))  +
  scale_fill_manual(values= met.brewer("Isfahan2", n = 4, type = "discrete", direction = -1)) +
  scale_color_manual(aes(color = "black")) +
  theme_sppdiv_discrete +
  labs(y =  "\U1D492 = 1", x = "", col = "") + 
  scale_y_continuous(expand = c(0.05, 0.05)) +
  stat_compare_means(comparisons = my_comparisons,
                     method = "wilcox.test", 
                     label = "p.signif") 
 # facet_wrap(~ Species, labeller = labeller(Species = labels_list)) +
 # guides(color = "none")        #To turn off color legend
  
hill1_species


# Hill number 2
# Inverse Simpson diversity or hill number 2
hill2_species <- ggplot(data = plant_traits_MB, 
                        aes(x = Species, y = hill_2)) +
  geom_boxplot(aes(fill = Species)) +
  # geom_crossbar(stat="summary",
  #               fun = mean,
  #               fun.max = mean,
  #               fun.min = mean,
  #               fatten = 1.5, width = 0.8) +
  # geom_point(color="black", alpha = 0.2,
  #            size=1.7, 
  #            position = position_jitter(w = 0.05))  +
  scale_fill_manual(labels=c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*'),
                    values= met.brewer("Isfahan2", n = 4, type = "discrete", direction = -1)) +
  scale_color_manual(aes(color = "black")) +
  theme_sppdiv_discrete +
  labs(y =  "\U1D492 = 2", x = "", col = "") + 
  stat_compare_means(comparisons = my_comparisons,
                     method = "wilcox.test", 
                     label = "p.signif") 
 # facet_wrap(~ Species, labeller = labeller(Species = labels_list)) +
 #guides(color = "none")        #To turn off color legend
  
hill2_species

# Joined plots
hill_numbers_species <- ggarrange(hill0_species, hill1_species, hill2_species, 
                                  nrow = 1, ncol = 3,
                                  common.legend = TRUE,
                                  labels = c("A", "B", "C"),
                                  legend = "bottom")

hill_numbers_species
#ggsave(filename = file.path(path, "figures/hill_numbers_species.png"), plot = hill_numbers_species, dpi=300, units=c("mm"), width=250, height=275)

#################################
#### Beta diversity ####
#### Across elevation ####
#################################

# Observed richness
# Hill number 0
hill0_beta <-  ggplot(plant_traits_MB, aes(x = Elevation_cat, y = Observed)) +
  geom_boxplot(aes(fill = Elevation_cat)) +
  # geom_crossbar(stat="summary", 
  #               fun = mean, 
  #               fun.max = mean, 
  #               fun.min = mean,  
  #               fatten = 2, 
  #               width = 0.5, 
  #               color="black") +
  # geom_point(aes(shape = Species),color="black", alpha = 0.4,size= 2.5, position = position_jitter(w=0.05)) +
   scale_color_manual(labels=c('Low', 'Mid', 'High'),values= met.brewer("Cassatt1", n = 3, type = "discrete", direction = -1)) +
  scale_fill_manual(labels=c('Low', 'Mid', 'High'),values= met.brewer("Cassatt1", n = 3, type = "discrete", direction = -1)) +
  scale_shape_manual(values=c(15:18),labels=c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*')) +
  theme_elevdiv_discrete +
  scale_x_discrete(labels = c('', '', '', '')) +
  stat_compare_means(comparisons = my_comparisons3,
                     method = "wilcox.test", 
                     label = "p.signif") +
  labs(y = "\U1D492 = 0", x = "") +
  guides(fill = guide_legend(title = "Elevation"), shape = guide_legend(title = "Species"))

hill0_beta

#ggsave(file.path(path, "figures/shannon_elevation.png") , plot = bbe, dpi=300, units=c("mm"), width=200, height=150)

# Hill number 1
# Shannon diversity or hill number 1
hill1_beta <- ggplot(plant_traits_MB, aes(x = Elevation_cat, y = hill_1)) +
  
  geom_boxplot(aes(fill = Elevation_cat)) +
  # geom_crossbar(stat="summary", 
  #               fun = mean, 
  #               fun.max = mean, 
  #               fun.min = mean,  
  #               fatten = 2, 
  #               width = 0.5, 
  #               color="black") +
  # geom_point(aes(shape = Species),color="black", alpha = 0.4,size= 2.5, position = position_jitter(w=0.05)) +
   scale_color_manual(labels=c('Low', 'Mid', 'High'),values= met.brewer("Cassatt1", n = 3, type = "discrete", direction = -1)) +
  scale_fill_manual(labels=c('Low', 'Mid', 'High'),values= met.brewer("Cassatt1", n = 3, type = "discrete", direction = -1)) +
  scale_shape_manual(values=c(15:18),labels=c('*M. laciniatus*', '*M. nasutus*', '*M. guttatus*')) +
  theme_elevdiv_discrete +
  scale_x_discrete(labels = c('', '', '', '')) +
  stat_compare_means(comparisons = my_comparisons3,
                     method = "wilcox.test", 
                     label = "p.signif") +
  labs(y = "\U1D492 = 1", x = "") +
  guides(fill = guide_legend(title = "Elevation"), shape = guide_legend(title = "Species"))

hill1_beta


# Hill number 2
# Inverse Simpson diversity or hill number 2

hill2_beta <- ggplot(plant_traits_MB, aes(x = Elevation_cat, y = hill_2, color = Elevation_cat)) +
  
  geom_boxplot(aes(fill = Elevation_cat), alpha = 0.5) +
  # geom_crossbar(stat="summary", 
  #               fun = mean, 
  #               fun.max = mean, 
  #               fun.min = mean,  
  #               fatten = 2, 
  #               width = 0.5, 
  #               color="black") +
  # geom_point(aes(shape = Species),color="black", alpha = 0.4,size= 2.5, position = position_jitter(w=0.05)) +
   scale_color_manual(labels=c('Low', 'Mid', 'High'),values= met.brewer("Cassatt1", n = 3, type = "discrete", direction = -1)) +
  scale_fill_manual(labels=c('Low', 'Mid', 'High'),values= met.brewer("Cassatt1", n = 3, type = "discrete", direction = -1)) +
  theme_elevdiv_discrete +
  scale_x_discrete(labels = c('', '', '', '')) +
  stat_compare_means(comparisons = my_comparisons3,
                     method = "wilcox.test", 
                     label = "p.signif") +
  labs(y = "\U1D492 = 2", x = "") +
  guides(fill = guide_legend(title = "Elevation"), color = guide_legend(title = "Elevation"))

hill2_beta


# Joining plots
hill_beta <- ggarrange(hill0_beta, hill1_beta, hill2_beta,
          nrow = 1, ncol = 3,
          common.legend = TRUE,
          legend = "bottom",
          labels = c("D", "E", "F"))
# hill_beta

#### Alpha and Beta diversity ####
# Joined plots
# A joined plot of joined plots


alpha_beta_diversity <- ggarrange(hill_numbers_species, "", hill_beta,
                          nrow = 3, ncol = 1,
                          common.legend = FALSE,
                          widths = c(1, 0.2, 1),
                          heights = c(1, 0.2, 1),
                          legend = "bottom")

alpha_beta_diversity

#ggsave(filename = file.path(path, "figures/figure3.png"), plot = alpha_beta_diversity, dpi=300, units=c("mm"), width=300, height=275)
```

#### Mantel tests and correlations

```{r, mantel}
#| echo: false
#| eval: true
#| tidy: true
# Prepare the data for correlation plot
# Longer format
asv_long <-  asv_avgdist |>
  as_tibble(rownames = "A") |>
  pivot_longer(-A, names_to = "B", values_to = "bray_diss")

geo_long <- geo_distm |>
  as_tibble(rownames = "A") |>
  pivot_longer(-A, names_to = "B", values_to = "geo_dist")

# Merge the two dataframes
asv_geo_matrix_long <- inner_join(asv_long, geo_long, by = c("A", "B")) |>
  inner_join(plant_traits |>
               dplyr::select(Unique_ID, Site, Species, Elevation_cat), by = c("A" ="Unique_ID"))

# Visualize the correlation
# Species labels
labels_list <- c("M. laciniatus", "M. nasutus", "M. guttatus")
names(labels_list) <- c("M. laciniatus", "M. nasutus", "M. guttatus")

# Correlation ggplot
mantel_test <- ggplot(asv_geo_matrix_long, aes(y = bray_diss, x = geo_dist)) +
  geom_jitter(aes(color = Species), alpha = 0.7, size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  scale_color_manual("Species", labels = c("*M. laciniatus*", "*M. nasutus*", "*M. guttatus*"), 
                      values = met.brewer("Isfahan2", 
                                          n = 4, 
                                          type = "discrete", direction = c(-1))) + 
   labs(y = "Bray_Curtis dissimilarity", x = "Geographic distance", col = "") + 
   scale_x_continuous(labels = function(x) format(x, scientific = FALSE)) +
  theme_lfspp_continuous +
  facet_wrap(~ Species)

mantel_test

#ggsave(file.path(path, "figures/mantel_test.png") , plot = mantel_test, dpi=300, units=c("mm"), width=200, height=150)

# Mantel test
# All data points
set.seed(859)
abund_geo  <- mantel(asv_avgdist, geo_distm, 
                     method = "spearman", 
                     parallel = 8,
                     permutations = 9999, 
                     na.rm = TRUE)
abund_geo

# Mantel test by species
# M. laciniatus

# Samples with species to subset/filter matrices downstream
# M. laciniatus
lac_names_rfy <- plant_traits |>
  slice(1:157) |> # Only selecting observations with ASV data 
  filter(Unique_ID %in% final_names_methodB,
    Species == "M. laciniatus") |>
  pull(Unique_ID) 

# Subset the data
lac_mantel  <- mantel(asv_long |> # Subset the data
                       filter(A %in% lac_names_rfy, B %in% lac_names_rfy) |>
                       pivot_wider(names_from = B, values_from = bray_diss) |>
                       column_to_rownames(var = "A") |>
                       as.matrix(),
                     geo_long |> # Subset the data
                       filter(A %in% lac_names_rfy, B %in% lac_names_rfy) |>
                       pivot_wider(names_from = B, values_from = geo_dist) |>
                       column_to_rownames(var = "A") |>
                       as.matrix(),
                      method = "spearman", permutations = 9999, na.rm = TRUE)
lac_mantel

# M. nasutus
nas_names_rfy <- plant_traits |> 
  slice(1:157) |> # Only selecting observations with ASV data 
  filter(Unique_ID %in% final_names_methodB,
         Species == "M. nasutus") |>
  pull(Unique_ID)
nas_mantel  <- mantel(asv_long |> # Subset the data
                       filter(A %in% nas_names_rfy, B %in% nas_names_rfy) |>
                       pivot_wider(names_from = B, values_from = bray_diss) |>
                       column_to_rownames(var = "A") |>
                       as.matrix(), 
                      geo_long |> # Subset the data
                       filter(A %in% nas_names_rfy, B %in% nas_names_rfy) |>
                       pivot_wider(names_from = B, values_from = geo_dist) |>
                       column_to_rownames(var = "A") |>
                       as.matrix(), 
                     method = "spearman", permutations = 9999, na.rm = TRUE)
nas_mantel

# M. guttatus
gut_names_rfy <- plant_traits |> 
  slice(1:157) |> # Only selecting observations with ASV data 
  filter(Unique_ID %in% final_names_methodB,
         Species == "M. guttatus") |>
  pull(Unique_ID)
# Subset the data
gut_mantel  <- mantel(asv_long |> # Subset the data
                       filter(A %in% gut_names_rfy, B %in% gut_names_rfy) |>
                       pivot_wider(names_from = B, values_from = bray_diss) |>
                       column_to_rownames(var = "A") |>
                       as.matrix(),
                     geo_long |> # Subset the data
                       filter(A %in% gut_names_rfy, B %in% gut_names_rfy) |>
                       pivot_wider(names_from = B, values_from = geo_dist) |>
                       column_to_rownames(var = "A") |>
                       as.matrix(),
                     method = "spearman", permutations = 9999, na.rm = TRUE)
gut_mantel
```

The correlation plot for Bray-Curtis dissimilarity and geographical distance shows a positive correlation. The more distant two sites are, the more dissimilar their FEF communities are (bray = 1). The Mantel test shows a significant correlation between the two matrices (r = 0.054, p \< 0.02).

### Communitty simple linear models

```{r, community_lm}
plot_regression(diversity ~ Elevation_m, meta(ps_melt))
plot_frequencies(tax_table(ps_clean_3), "Phylum", "Species")
ps <- add_refseq(ps_clean_3)
print(p)


summarize_phyloseq(ps_clean_3)


# Hill number 0
ggplot(ps_melt, aes(x = Abundance, y = Observed)) +
  geom_jitter(aes(color = sample_Species), alpha = 0.7, size = 3) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(y = "𝑞 = 0", x = "Abundance", col = "") +
  theme_classic(base_size = 12) +
  theme(legend.title = element_text(face = "bold"),
        strip.text = element_text(face = "italic", size = 14),
        panel.border = element_rect(linetype = "blank", fill = NA),
        legend.text = element_markdown(size = 12), #Make legend text italic
        axis.text.x = element_text(size = 12),
        axis.title.x = element_text(size = 14))

# Hill number 1
# Shannon diversity or hill number 1
ggplot(ps_melt, aes(x = Abundance, y = hill_1)) +
  geom_jitter(aes(color = sample_Species), alpha = 0.7, size = 3) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(y = "𝑞 = 1", x = "Abundance", col = "") +
  theme_classic(base_size = 12) +
  theme(legend.title = element_text(face = "bold"),
        strip.text = element_text(face = "italic", size = 14),
        panel.border = element_rect(linetype = "blank", fill = NA),
        legend.text = element_markdown(size = 12), #Make legend text italic
        axis.text.x = element_text(size = 12),
        axis.title.x = element_text(size = 14))

# Hill number 2
# Inverse Simpson diversity or hill number 2
ggplot(ps_melt, aes(x = Abundance, y = hill_2)) +
  geom_jitter(aes(color = sample_Species), alpha = 0.7, size = 3) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(y = "𝑞 = 2", x = "Abundance", col = "") +
  theme_classic(base_size = 12) +
  theme(legend.title = element_text(face = "bold"),
        strip.text = element_text(face = "italic", size = 14),
        panel.border = element_rect(linetype = "blank", fill = NA),
        legend.text = element_markdown(size = 12), #Make legend text italic
        axis.text.x = element_text(size = 12),
        axis.title.x = element_text(size = 14))


```

### Leaf traits Simple Linear model

Regressions presented at Evo 2023.

```{r}
# Regressions
# Elevation_m and Thicknes
  
t <-ggplot(data = leaf_traits, aes(y= Thickness, x = Elevation_m, color = Species)) +
   geom_jitter(aes(color = Species,), size = 2, alpha = 0.5, na.rm = TRUE)+
#scale_shape_manual(values=c(1:24)) +
  scale_color_manual(values= met.brewer("Isfahan2", n = 4, type = "discrete"))+
  geom_smooth(method=lm, se = F) +
 # stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 700, label.x = 6000, aes(label = ..eq.label..), sep = "~~~~", size = rel(3), color= "black") +
  stat_regline_equation(label.y = 650 , label.x = 6000, aes(label = ..adj.rr.label..), size = rel(3),color = "black") +
  labs(y="Leaf thickness (/u03BCm)", x = "Elevation_m (f.a.s.l.)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
#caption = "**All replicate leaves from tree species included  (n = 210)", col = "Treatment"
t
```

```{r}
# fit <- lm(logit_herbivory ~ Thickness, data = masterant2)
# 
# rSquared <- summary(fit)$r.squared
# rSquared
# anova(fit)
# pVal <- anova(fit)$'Pr(>F)'[1]
# pVal

# Elevation_m and Anthocyanins

a <- ggplot(data = leaf_traits, aes(y= ACI, x= Elevation_m, color = Species))+
   geom_jitter(aes(color = Species), size = 2, alpha = 0.5) +
  #scale_shape_manual(values=c(15:22)) +
  scale_color_manual(values= met.brewer("Isfahan2", n = 4, type = "discrete")) +
  geom_smooth(method=lm, se=F) +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 30, label.x = 6000, aes(label = ..eq.label..), size = rel(3), color= "black") +
  stat_regline_equation(label.y = 25 , label.x = 6000, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(y="Anthocyanins (ACI)", x="Elevation_m (f.a.s.l.)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title =element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
 
a
#scale_shape_manual(values = c(1:7))
```

```{r}
# Herbivory and leaf thickness

tt <- ggplot(data = masterant2, aes(y= logit_herbivory, x= Thickness, color = E_load))+
   geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 2.5, label.x = 200, aes(label = ..eq.label..), size = rel(3), color= "black") +
  stat_regline_equation(label.y = 2 , label.x = 200, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(x="Leaf thickness (/u03BCm)", y = "logit(Leaf herbivory) (%)") +
 theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none")
tt

# Herbivory and LMA

lma <- ggplot(data = masterant2, aes(y= logit_herbivory, x= LMA, color = E_load))+
  geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 2.5, label.x = 0.001, aes(label = ..eq.label..), size = rel(3), color= "black") +
  stat_regline_equation(label.y = 2 , label.x = 0.001, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(x="Leaf mass per area (LMA)", y = "logit(Leaf herbivory) (%)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
 
lma

# Herbivory and FEF Shannon Diversity
# Extracting effect size of model to plot
 dv <- ggplot(data = masterant2, aes(y= logit_herbivory, x= Shannon, color = E_load))+
  geom_jitter(aes(color = E_load, color = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
 # stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  #scale_fill_manual(values= met.brewer("Cross", n = 8, type = "discrete")) +
  #scale_color_manual(values= met.brewer("Cross", n = 8, type = "discrete")) +
  stat_regline_equation(label.y = 2.5, label.x = 1.5, aes(label = ..eq.label..),size = rel(3), color= "black") +
  stat_regline_equation(label.y = 2 , label.x = 1.5, aes(label = ..adj.rr.label..), size = rel(3),color = "black") +
  labs(x="Shannon diversity index", y="logit(Leaf herbivory) (%)") +
  theme_minimal(base_size = 10) +
 theme(legend.position="right",
        legend.text = element_text(size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7))
  # guides(color = "none")  +      #To turn off color legend
  # guides(fill = "none") + #To turn off fill legend
  # guides(shape = "none") #To turn off shape legend
 
 dv

 # Multiples plots together

ant_arranged <- ggarrange(t, tt, a, lma, dv, nrow = 2, ncol=3, common.legend = TRUE, legend="right")


# Adding caption
ant_caption <- "*All individuals per tree species included (n = 210)"
ant_arranged_with_caption <- annotate_figure(ant_arranged, bottom = text_grob(ant_caption), fig.lab.pos = "bottom.right", fig.lab.size = 6)

ant_arranged_with_caption

#ggsave(filename = "./Plots/Aim3_ant_regression_06042023.png", plot = ant_arranged_with_caption, dpi=600, units=c("mm"), width=180, height=140, bg = "white")

```

#### ASV barplot

```{r, asv_barplot}
#Barplots with microeco
# Quick addition trais log transformed
ps_clean_3@sam_data <- plant_traits |>
  filter(Unique_ID %in% names_list) |>
  select(c(1:12, 15:20)) |>
  sample_data()

micro_psclean <- phyloseq2meco(ps_clean_3) # First convert phyloseq to meco


t1 <- trans_abund$new(dataset = micro_psclean, taxrank = "Phylum", ntaxa = 8)
t1gg <- t1$plot_bar(others_color = "grey70", facet = c("Species", "Elevation_cat"), xtext_keep = FALSE, legend_text_italic = FALSE, color_values = RColorBrewer::brewer.pal(8, "Set3"))
t1gg <- t1gg + theme(legend.title = element_text(face = "bold"),
         strip.text = element_text(face = "bold.italic", size = 12),
         panel.border = element_rect(linetype = "blank", fill = NA),
         axis.text.x = element_blank())
t1gg
#ggsave(file.path(path, "figures/figure3.png") , plot = t1gg, dpi=300, units=c("mm"), width=200, height=250)

# rarefied Abundance
micro_rarefied_ps <- phyloseq2meco(rarefied_phyloseq) # First convert phyloseq to meco

r1 <- trans_abund$new(dataset = micro_rarefied_ps, taxrank = "Phylum", ntaxa = 8)
r1gg <- r1$plot_bar(others_color = "grey70", facet = c("Species", "Elevation_cat"), xtext_keep = FALSE, legend_text_italic = FALSE, color_values = RColorBrewer::brewer.pal(8, "Set3"))
r1gg <- r1gg + theme(legend.title = element_text(face = "bold"),
         strip.text = element_text(face = "bold.italic", size = 12),
         panel.border = element_rect(linetype = "blank", fill = NA),
         axis.text.x = element_blank())
r1gg

r2 <- trans_abund$new(dataset = micro_rarefied_ps, taxrank = "Genus", ntaxa = 10)
r2gg <- r2$plot_heatmap(facet = c("Species", "Elevation_cat"), xtext_keep = FALSE, withmargin = FALSE) + theme(legend.title = element_text(face = "bold"),
         strip.text = element_text(face = "bold.italic", size = 12),
         panel.border = element_rect(linetype = "blank", fill = NA),
         axis.text.x = element_blank())

r2gg
```

### dbRDA

#### dbRDA modelling + PERMDISP

##### Hellinger transformed rarefied data

```{r}
# Traits for dbRDA
dbrda_hell_matrix <- rrfy_hell_matrix |>
  column_to_rownames(var = "X") |>
  select(-c(1, 233:256))

dbrda_traits <- rrfy_hell_matrix |>
  select(X, Unique_ID, Site, Species, Elevation_m, Elevation_cat, Sample_Date, logACI, logLT, logLPS, logLMA, logLBI)|>
  unite(Species_Elevation, Species, Elevation_cat, sep = "_", remove = FALSE) # To model interactions
```

```{r}
# Model with intercept only ####
# Using rrfy_hell_matrix as the distance matrix
m0_hell <- dbrda(dbrda_hell_matrix ~ 1,
            distance = "bray",
            dfun = vegdist,
            data = dbrda_traits,
            parallel = 8, #Passes parallelization to metaMDS function
            na.action = na.omit) #Model with intercept only.

m1_hell <- dbrda(dbrda_hell_matrix ~ ., 
            distance = "bray", 
            dfun = vegdist,
            data = dbrda_traits,
            parallel = 8, #Passes parallelization to metaMDS function
            na.action = na.omit) # Model with all explanatory variables.

# Model with species, site, leaf traits and elevation. ####
m2_hell <- dbrda(dbrda_hell_matrix ~ logLBI + Elevation_m + Sample_Date + Site + Species,  
            distance = "bray",
            dfun = vegdist,
            data = dbrda_traits,
            parallel = 8, #Passes parallelization to metaMDS function
            na.action = na.omit)

#Anovas for m2
set.seed(123)
anova.cca(m2_hell, by = "margin", permutations = 999, parallel = 8) # .cca adds Distance based CCA functionality
anova(m2_hell, by = "axis")
anova(m2_hell, by = "axis", perm.max=500)
```

##### Forward and backward selection with ordistep

```{r}
#Both, forward and backward selection. This way I can see the step by step.
#m3
# m2.forsel <-  ordistep(m0, scope = formula(m1), Pin = 0.009, Pout = 0.06 , 
#                        trace = T, 
#                        permutations = how(nperm = 10),
#                        parallel = 8,
#                        steps = 50, 
#                        direction = "both", 
#                        na.action = na.omit)
# 
# m2.forsel <-  ordiR2step(m0, m1, 
#                        Pin = 0.009,
#                        R2scope = TRUE,
#                        permutations = how(nperm = 499), 
#                        trace = TRUE, 
#                        R2permutations = 1000, 
#                        na.action = na.omit)
# 

#summary(m2.forsel)
#anova(m2.forsel, by = "margin") # test for sign. environ. variables 
```

::: warning
Ordistep fails to compute with `dbrda_hell_matrix`. Results from `anova.cca` on m2 show that all terms are significant. This is too good to be true and seems to be overfitting. I will try to remove the least significant terms and re-run the model. From `vif.cca` help page: *Variance inflation is a diagnostic tool to identify useless constraints. A common rule is that values over 10 indicate redundant constraints.*
:::

```{r}
#Variance inflation factor for constrained ordination
vif.cca(m2)
```

All of the sampling dates are redundant. I will remove `Sampling_Date` term. Elevation also has an extremely high `vif`, but it is part of the question. Let's keep it for a minute.

```{r}
# No sampling date
m3_hell <- dbrda(dbrda_hell_matrix ~  logLBI + Elevation_m + Site + Species,  
            distance = "bray",
            dfun = vegdist,
            data = dbrda_traits,
            parallel = 8, #Passes parallelization to metaMDS function
            na.action = na.omit)
# Save
save(m3_hell, file = "clean_data/statistics/m3_hell.rda")

# Load
load("clean_data/statistics/m3_hell.rda")


vif.cca(m3_hell)
summary(m3_hell)

set.seed(123)
anova_m3hell <- anova.cca(m3_hell, by = "margin", permutations = 999, parallel = 8)

# Save
save(anova_m3hell, file = "clean_data/statistics/anova_m3hell.rda")
#Load
load("clean_data/statistics/anova_m3hell.rda")
```

Sites are redundant. It over fits the model given all the site factors (n= 21)

```{r}
# No site no interations
m4_hell <-
  dbrda(
    dbrda_hell_matrix ~  logLBI + Elevation_m + Species,
    distance = "bray",
    dfun = vegdist,
    data = dbrda_traits,
    parallel = 8,
    #Passes parallelization to metaMDS function
    na.action = na.omit
  )

# Save
save(m4_hell, file = "clean_data/statistics/m4_hell.rda")

# Load
load("clean_data/statistics/m4_hell.rda")

vif.cca(m4_hell)
summary(m4_hell)

set.seed(123)
anova_m4hell <-
  anova.cca(m4_hell,
            by = "margin",
            permutations = 999,
            parallel = 8)

# Save
save(anova_m4hell, file = "clean_data/statistics/anova_m4hell.rda")
#Load
load("clean_data/statistics/anova_m4hell.rda")



# m5 with interactions
m5_hell <- 
  dbrda(
    dbrda_hell_matrix ~  logLBI + Elevation_m * Species,
    distance = "bray",
    dfun = vegdist,
    data = dbrda_traits,
    parallel = 8,  #Passes parallelization to metaMDS function
    na.action = na.omit
  )

# Save
save(m5_hell, file = "clean_data/statistics/m5_hell.rda")

#load
load("clean_data/statistics/m5_hell.rda")

#Anovas for m5
vif.cca(m5_hell)
summary(m5_hell)

# Margin
set.seed(123)
anova_m5hell_margin <-
  anova.cca(m5_hell,
            by = "margin",
            permutations = 999,
            parallel = 8)
save(anova_m5hell, file = "clean_data/statistics/anova_m5hell_margin.rda")
load("clean_data/statistics/anova_m5hell_margin.rda")

# Terms (results are the same as adonis2 but without R2)
set.seed(123)
anova_m5hell_term <-
  anova(m5_hell,
        by = "term",
        permutations = 999,
        parallel = 8)
save(anova_m5hell_term, file = "clean_data/statistics/anova_m5hell_term.rda")
load("clean_data/statistics/anova_m5hell_term.rda")


###################################
### PERMDISP ######################
###################################

#Analysis of multivariate homogeneity of group dispersions.

# By Species
set.seed(123)
beta_dis1 <-
  betadisper(
    vegdist(dbrda_hell_matrix, method = "bray"),
    # Matrix of Hellinger transformed data rarefied
    dbrda_traits$Species,
    type = "median",
    sqrt.dist = FALSE
  )
save(beta_dis1, file = "clean_data/statistics/beta_dis1.rda")
load(file = "clean_data/statistics/beta_dis1.rda")
anova(beta_dis1)

set.seed(123)
beta_perm1 <-
  permutest(beta_dis1,
            parallel = 8,
            permutations = 999,
            by = "term")
save(beta_perm1, file = "clean_data/statistics/beta_perm1.rda")
load("clean_data/statistics/beta_perm1.rda")
beta_perm1

TukeyHSD(beta_dis1, conf.level = 0.95)


# By Elevation
set.seed(123)
beta_dis2 <- betadisper(
  vegdist(dbrda_hell_matrix, method = "bray"),
  dbrda_traits$Elevation_cat,
  type = "median",
  sqrt.dist = FALSE
)
save(beta_dis2, file = "clean_data/statistics/beta_dis2.rda")
load(file = "clean_data/statistics/beta_dis2.rda")
# anova(beta_dis2)

set.seed(123)
beta_perm2 <-
  permutest(beta_dis2,
            parallel = 8,
            permutations = 999,
            by = "term")
save(beta_perm2, file = "clean_data/statistics/beta_perm2.rda")
load(file = "clean_data/statistics/beta_perm2.rda")

beta_perm2
TukeyHSD(beta_dis2, conf.level = 0.95)

# By Elevation*Species
set.seed(123)
beta_dis3 <- betadisper(
  vegdist(dbrda_hell_matrix, method = "bray"),
  dbrda_traits$Species_Elevation,
  type = "median",
  sqrt.dist = FALSE
)
save(beta_dis3, file = "clean_data/statistics/beta_dis3.rda")
load(file = "clean_data/statistics/beta_dis3.rda")

set.seed(123)
beta_perm3 <-
  permutest(beta_dis3,
            parallel = 8,
            permutations = 999,
            by = "term")
save(beta_perm3, file = "clean_data/statistics/beta_perm3.rda")

TukeyHSD(beta_dis3, conf.level = 0.95)

```



#### Plot dbRDA

```{r, final_model}
# Final model
final_model <- m5_hell

names(final_model)
B <- summary(final_model)


# Extracting scores for the plot
ordination_scores <- as.data.frame(vegan::scores(final_model)$sites)

# Extracting names for the plot
ordination_names <- rownames(ordination_scores)

# Row names to column
ordination_scores$Unique_ID <- rownames(ordination_scores)

# Subset for the plot
dbrda_df <- plant_traits_MB
  #filter(Unique_ID %in% ordination_names)

# Merge scores with trait data
merged_data <- right_join(ordination_scores, dbrda_df, by = c("Unique_ID" = "X"))

# Extracting scores for arrows
arrow_scores <- as.data.frame(vegan::scores(final_model, display = "bp"))

# Define the arrow aesthetic mapping
arrow_map <- aes(xend = (dbRDA1*2), yend = (dbRDA2*2), x = 0, y = 0, shape = NULL, color = NULL, fill = NULL)
label_map <- aes(x = 2*dbRDA1, y = 2*dbRDA2, label = row.names(arrow_scores), shape = NULL, color = NULL, fill = NULL)
arrowhead = arrow(length = unit(0.02, "npc"))

#subset A4 for labeling
arrow_scores <- arrow_scores[order(rownames(arrow_scores)), ]
A4 <- lapply(1:6, function(i) arrow_scores[i, ])

A4.sub1 <- arrow_scores[1,] #Elevation
A4.sub2 <- arrow_scores[2,] #ACi
A4.sub3 <- arrow_scores[3,] #LBI
A4.sub4 <- arrow_scores[4,] #LMA
A4.sub5 <- arrow_scores[5,] #LPS
A4.sub6 <- arrow_scores[6,] #LT.

# dbRDA plot based on species
p_final_model <- ggplot(data = merged_data, aes(x = dbRDA1, y = dbRDA2)) +
  geom_point(data = merged_data, aes(color = Species, shape = Site), size = rel(4), alpha = 0.7, stroke = 1) +
  geom_segment(arrow_map, size = rel(.8), data = arrow_scores, color = "black", arrow = arrowhead) +
  geom_vline(xintercept = 0, color = "grey30", linetype = "dashed") + # plot vertical line
  geom_hline(yintercept = 0, color = "grey30", linetype = "dashed") + # plot horizontal line
  geom_text(label_map, size = rel(4), data = A4[[1]], fontface = "bold", show.legend = FALSE, label = c("Elev.")) +
  geom_text(label_map, size = rel(4), data = A4[[2]], fontface = "bold", show.legend = FALSE, label = c("logACI")) +
  geom_text(label_map, size = rel(4), data = A4[[3]], fontface = "bold", show.legend = FALSE, label = c("logLBI")) +
  geom_text(label_map, size = rel(4), data = A4[[4]], fontface = "bold", show.legend = FALSE, label = c("logLMA")) +
  geom_text(label_map, size = rel(4), data = A4[[5]], fontface = "bold", show.legend = FALSE, label = c("logLPS")) +
  geom_text(label_map, size = rel(4), data = A4[[6]], fontface = "bold", show.legend = FALSE, label = c("logLT")) +
  xlab(label = paste("dbRDA1 (", round(B$concont$importance[2,1]*100, digits = 1), "%)", sep="")) +
  ylab(label = paste("dbRDA2 (", round(B$concont$importance[2,2]*100, digits = 1), "%)", sep="")) + 
  scale_color_manual(values= met.brewer("Isfahan2", n = 3, type = "discrete", direction = -1)) +
  scale_shape_manual(values=c(1:22)) +
  stat_ellipse(aes(color = Species),
               geom = "path",
               linewidth = 1.7,
               position = "identity",
               type = "t", linetype = 1,
               level = 0.95,
               segments = 51,
               na.rm = FALSE,
               show.legend = NA, inherit.aes = TRUE) +
  theme_classic(base_size = 16) +
  theme(legend.title = element_text(face = "bold"),
        legend.text = element_text(face = "italic")) +
  guides(shape = guide_legend(ncol=2))

     
# Rearranging the order of layers so arrows are above the points.
p_final_model$layers
p_final_model$layers <- c(p_final_model$layers, p_final_model$layers[[5]], p_final_model$layers[[6]])
p_final_model

#ggsave(filename=file.path(path, "figures/dbRDA_species.png"), plot = p_m2dbrda, dpi=600, units=c("mm"), width=150, height=150)
```

### PERMANOVA

```{r, adonis2}
# Real data
set.seed(123)
perma <- adonis2(t(asv_matrix) ~ logACI + logLT + logLPS + logLMA +
                   Elevation_m + 
                 
                   Species,
                 data = dbrda_real_traits,
                 method = "bray",
                 parallel = 8,
                 permutation = 999, 
                 na.action = na.omit, 
                 strata = NULL)
print(perma)

# Rarefied data
set.seed(123)
perma2 <- adonis2(dbrda_hell_matrix ~ logACI + logLT + logLPS + logLMA +
                   Elevation_m + 
                   Species,
                 data = dbrda_traits,
                 method = "bray",
                 parallel = 8,
                 permutation = 999, 
                 na.action = na.omit, 
                 strata = NULL)
print(perma2)

# Modelling dbRDA m5_hell
set.seed(123)
perma3 <- adonis2(
  dbrda_hell_matrix ~ logLBI + Elevation_m *
    Species,
  data = dbrda_traits,
  method = "bray",
  parallel = 8,
  permutation = 999,
  na.action = na.omit,
  strata = NULL
)
save(perma3, file = "clean_data/statistics/perma3.rda")
load("clean_data/statistics/perma3.rda")
print(perma3)
```




### PCA for community data
```{r, comm_pca}
#| echo: false
#| eval: true
#| tidy: true
#| label: pca
#| fig-cap: "PCA of leaf traits by species."

# PCA using covariates to explain species richness/abundance ####

data.pca <- dbrda_hell_matrix # Renaming and using same data set as dbRDA

leaf_traits.pca <- plant_traits_MB


###Run this to create pca with prcomp function
pca <- prcomp(data.pca, scale = FALSE) # Scaling is not necessary as the data is already Hellinger transformed
pca$rotation=-pca$rotation
pca$x=-pca$x

#Checking the PCA
plot(pca,type = "lines")
biplot(pca) # Base type PCA

# PCA using autoplot() and prcomp()and modifying with ggplot syntax ####
pca_auto <- autoplot((pca), data = data.frame(leaf_traits.pca), # For some reason this functions require data to be data= data.frame()
         alpha = 0, #Setting alpha to zero render the automatic circle point null.Manipulate shapes with geom_point(). 
         loadings = TRUE,loadings.colour = "black",
         loadings.label = TRUE, loadings.label.colour="black",
         loadings.label.size = 4, size = 7, 
         loadings.label.vjust = 0, 
         loadings.label.hjust = -0.15) + 
  geom_point(aes(fill = Species, color = Species), alpha = 0.5, size = 3) +
  geom_hline(yintercept = 0, colour = "gray45") +
  geom_vline(xintercept = 0, colour = "gray45") +
    scale_fill_manual(labels=c("*M. laciniatus*", "*M. nasutus*", "*M. guttatus*"), 
                    values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  scale_color_manual(labels = c("*M. laciniatus*", "*M. nasutus*", "*M. guttatus*"),
                     values = met.brewer("Isfahan2", n = 4, type = "discrete", direction = c(-1))) +
  stat_ellipse(aes(color = Species), 
               geom = "path", 
               size = 1.3, 
               position = "identity", 
               type = "t", 
               linetype = 1, 
               level = 0.95, 
               segments = 51, na.rm = TRUE, show.legend = NA, inherit.aes = TRUE) +
  #scale_x_continuous(expand = c(0.0, -0.09)) +
  theme_classic(base_size = 12) +
  theme(legend.text = element_markdown(),
        legend.position = "bottom",
        legend.title = element_text(face = "bold")) 
  # labs(caption = expression("ACI = anthocyanins, LPS = leaf punch strength, LMA = leaf mass per area, LT = leaf thickness. LBI = Leaf lobe index. All leaf replicates per species ("~ italic("n") ~ "= 501)."))


pca_auto$layers <- c(pca_auto$layers, pca_auto$layers[[2]], pca_auto$layers[[3]]) # This adds/copies layers 2-3 and overlays them. It makes the arrows be on top of the points. There must be a better ways of doing this.

pca_auto
```

This is an interesting analysis. A PCA of the fungal communities is not that different from the dbRDA, qualitatively. But we appreciate the ASVs driving the patterns. We observed that the most abundant and prevalent ASV have the longest/strongest vectors. From [@armstrong2022]: "(Morton et al., 2019) and neither rarefaction nor relative abundance sampling solve this issue. Due to this effect, many dimensionality reduction methods, such as PCA, will emphasize false correlations in the data"

See paper for discussion on appropriate dimensionality reduction methods fro microbial data. 

### PCoA

```{r, pcoa}
# Custom function to run PCoA
# OTU matrix must be transformed already (e.g. Hellinger). See Matrices section.

matx_ordi <- function(x, dsim = "bray", md = c("pca", "pcoa"), ...){ 
dist <- vegdist(x, method = dsim)
  switch(md,
         pca = pca <- prcomp(dist),
         pcoa = pcoa <- wcmdscale(dist, eig = TRUE))
}

# PCoA
pcoa_object <- matx_ordi(dbrda_hell_matrix, md = "pcoa", k =3)
save(pcoa_object, file = "clean_data/statistics/pcoa_object.rda")

pcoa_df <- data.frame(pcoa_object$points) |>
rownames_to_column(var = "Unique_ID") 


# Merge scores with trait data
pcoa_merged_data <- right_join(pcoa_df, plant_traits_MB, by = c("Unique_ID" = "X")) |>
subset(select = -c(Unique_ID.y))

# Extract eigenvalues and calculate the percentage of variance explained by each axis
explained_variance <- pcoa_object$eig / sum(pcoa_object$eig) * 100
pretty_percent <- format(round(explained_variance, digits = 1), nsma = 1, trim = TRUE)

# PCoA plot based on species
# Remember, a dbRDA is an RDA run on a PCoA. So, the PCoA is the first step in the analysis.
pcoa_plot <- ggplot(data = pcoa_merged_data, aes(x = Dim1, y = Dim2)) +
  geom_point(aes(color = Species), size = rel(4), alpha = 0.2, stroke = 1) +
  geom_vline(xintercept = 0, color = "grey30", linetype = "dashed") + # plot vertical line
  geom_hline(yintercept = 0, color = "grey30", linetype = "dashed") + # plot horizontal line
  xlab(label = paste("PCoA1 (", pretty_percent[1], "%)", sep="")) +
  ylab(label = paste("PCoA2 (", pretty_percent[2], "%)", sep="")) +
  scale_color_manual(
    labels = c("*M. laciniatus*", "*M. nasutus*", "*M. guttatus*"),
    values = met.brewer("Isfahan2", n = 3, type = "discrete",
    direction = -1)) +
  scale_shape_manual(values=c(1:22)) +
  stat_ellipse(aes(color = Species),
               geom = "path",
               linewidth = 1.7,
               position = "identity",
               type = "t", linetype = 1,
               level = 0.95,
               segments = 51,
               na.rm = FALSE,
               show.legend = NA, inherit.aes = TRUE) +
theme_classic(base_size = 16) +
theme(legend.title = element_text(face = "bold"),
legend.text = element_markdown(),
legend.position = "bottom",
plot.caption = element_markdown(),
strip.text = element_text(face = "bold"))

pcoa_plot
```

### PCoA and dbRDA comparison

```{r, pcoa_dbrda}
# PCoA and dbRDA comparison
joined <- ggarrange(
pcoa_plot,
p_final_model,
nrow = 1,
ncol = 2,
common.legend = TRUE,
legend = "bottom",
labels = c("PCoA", "dbRDA")
) #, widths = c(1, 1))

joined

ggsave(file.path(path, "figures/pcoa_dbrda.png"), plot = joined, dpi=300, units=c("mm"), width=300, height=300)
```


### PCoA Linear regressions

```{r}
# PCoA regressions
# PCoA1

alpha_pcoa1 <- lm(hill_1 ~ Dim2, data = pcoa_merged_data)
plot(alpha_pcoa1)


alpha_pcoa <- ggplot(data = pcoa_merged_data, aes(y= hill_1, x =Dim1, color = Species)) +
geom_point(aes(color = Species), size = rel(4), alpha = 0.2, stroke = 1) +
geom_smooth(method = "lm", se = FALSE) +
labs(y =  "Alpha diversity (\U1D492 = 1)", x = paste("PCoA1 (",pretty_percent[1], "%)", sep = "")) +
scale_color_manual(
    labels = c("*M. laciniatus*", "*M. nasutus*", "*M. guttatus*"),
    values = met.brewer("Isfahan2", n = 3, type = "discrete",
    direction = -1)) +
theme_classic(base_size = 16) +
theme(legend.title = element_text(face = "bold"),
legend.text = element_markdown(),
legend.position = "bottom",
plot.caption = element_markdown(),
strip.text = element_text(face = "bold"))


# Joining plots

pcoa_pcr_dbrda_joined <- ggarrange(
pcoa_plot,
alpha_pcoa,
p_final_model,
nrow = 1,
ncol = 3,
common.legend = TRUE,
legend = "bottom",
labels = c("PCoA", "Alpha diversity", "dbRDA"),
widths = c(1,1,1)
)

pcoa_pcr_dbrda_joined

ggsave(file.path(path, "figures/pcoa_pcr_dbrda.png") , plot = pcoa_pcr_dbrda_joined, dpi=300, units=c("mm"), width=350, height=300)
```

The simple linear model does not bode well. When we plot the residuals, fitted values and Cook's distance we see it suffers from heteroscedasticity and outliers. The PCoA and dbRDa are qualitatively very similar. We observed overlapped of fungal communitites in *Mimulus* spp. A lot of the microbial literature presents PCoA, alphadiversity measures and PERMANOVA table. My issue with PCoA and doing a PCR with a measure of alpha diversity or similar is that the model fit is not good at all. Visually it represents how at higher elevation we have lower alpha diversity levels. But this is information that is already present in the "boxplot_hill_orders" plots. I don't think the PCoA adds more information.


## Linear regressions with Taxa of interest

```{r, linear_regression}
# Exploring PCoA with taxa of interest.

test <- data.frame(t(rep_otu_df(pseq_rrfb))) |>
rownames_to_column(var = "X") |>
  mutate(Unique_ID =  X, # Copyin column to new column 
         Unique_ID =  str_remove(Unique_ID, "^.*?(_|-)")) |>
  relocate(Unique_ID, .after = X) |>
  left_join(plant_traits, by = "Unique_ID")


test <- ggplot(test, aes(y= ASV_1, x = Elevation_m)) +
geom_point(color = "black", size = rel(4), alpha = 0.2, stroke = 1) +
geom_smooth(method = "lm", se = FALSE) +
labs(y =  "Cold-tolerant fungus (ASV_1)", x = paste("Elevation (m)", sep = "")) +
# scale_color_manual(
#     labels = c("*M. laciniatus*", "*M. nasutus*", "*M. guttatus*"),
#     values = met.brewer("Isfahan2", n = 3, type = "discrete",
#     direction = -1)) +
theme_classic(base_size = 16) +
theme(legend.title = element_text(face = "bold"),
legend.text = element_markdown(),
legend.position = "bottom",
plot.caption = element_markdown(),
strip.text = element_text(face = "bold"))


ggsave(file.path(path, "figures/cold-tolerant_asv1.png") , plot = test, dpi=300, units=c("mm"), width=250, height=250)
```





# Who contributes more to differences in the community composition?

```{r, SIMPER}
(sim <- with(dbrda_traits, simper(dbrda_hell_matrix, Species, permutations = 9999, parallel = 8)))
summary(sim)
```

# Indicator species analysis

This analysis allows us to determine what endophytes are associated with particular groups (e.g. tree species). According to this vignette from Cáceres ([2022](https://cran.r-project.org/web/packages/indicspecies/vignettes/IndicatorSpeciesAnalysis.html)) `multipatt` function can provides us with Indicators Value Index and correlation index. Both are similar, but the differences lies in the question they help answer. Indicator value index "\[...\]are used for assessing the predictive values of species as indicators of the conditions prevailing in site groups, e.g. for field determination of community types or ecological monitoring." While the correlation index can be used for "\[...\] determining the ecological preferences of species among a set of alternative site groups or site group combinations."

```{r, indicspp}
#Subset data frame for indicator species analysis
#Community Data
test <- as.matrix(t(rep_otu_df(pseq_rrfb)))
                 
asv_matrix_df <- as.data.frame(as.matrix(t(rep_otu_df(pseq_rrfb))))|># mirl object
  rownames_to_column(var = "Unique_ID") 
asv_indicspp <- left_join(asv_matrix_df, dbrda_traits, by = "Unique_ID")|> # Joining to the NMDS traits data frame which has the same number of rows as the asv_matrix_df
    select(!c(238:243)) |>
  relocate(Species, Site, Elevation_cat, Elevation_m, .after = Unique_ID)
```

```{r indicspp}
#Making vector of groups for analysis
set.seed(123)
indiabun <- asv_indicspp[, 7:ncol(asv_indicspp)]

species <- asv_indicspp$Species
elecat <- asv_indicspp$Elevation_cat
site <- asv_indicspp$Site

# Indicator species analysis`
multipatt_analysis = multipatt(indiabun, species, func = "r.g", control = how(nperm=999)) #By using abundance data and not presence-absence we are calculating the "point biserial correlation coefficient"
multipatt_analysis
summary(multipatt_analysis, indvalcomp = TRUE)


# Indicator species analysis by elevation category
multipatt_analysis_ele <- multipatt(indiabun, elecat, func = "r.g", control = how(nperm=999))
multipatt_analysis_ele
summary(multipatt_analysis_ele, indvalcomp = TRUE)

```

```{r, Type I errror and data table, tidy = TRUE}
#Correcting for type 1 error and multiple comparisons
#code from this post
#https://stats.stackexchange.com/questions/370724/indiscpecies-multipatt-and-overcoming-multi-comparrisons/401277#401277

# By Mimulus Species
#Extract table of stats
multipatt_analysis_sign <- as.data.table(multipatt_analysis$sign, keep.rownames=TRUE)

# #Add adjusted p-value
multipatt_analysis_sign[, p.adj := p.adjust(p.value, method = "BH")] #This can also be calculated with `dplyr` and `tidyr`
# #indval.table <- indval.sign |>
#   #mutate(p.value.bh = p.adjust(p.value, method = "BH"))
 
# #Now we can select only the indicators with adjusted significant p-values
multipatt_analysis_sign <- multipatt_analysis_sign[p.adj <= 0.06,]

#Renaming the first column
colnames(multipatt_analysis_sign)[1]  <- "ASV" 

# By Elevation
#Extract table of stats
multipatt_analysis_elev_sign <- as.data.table(multipatt_analysis_ele$sign, keep.rownames=TRUE)

# #Add adjusted p-value
multipatt_analysis_elev_sign[, p.adj := p.adjust(p.value, method = "BH")] #This can also be calculated with `dplyr` and `tidyr`
# #indval.table <- indval.sign |>
#   #mutate(p.value.bh = p.adjust(p.value, method = "BH"))
 
# #Now we can select only the indicators with adjusted significant p-values
multipatt_analysis_elev_sign <- multipatt_analysis_elev_sign[p.adj <= 0.06,]

#Renaming the first column
colnames(multipatt_analysis_sign)[1]  <- "ASV" 
```

No ASVs significantly correlated with Mimulus species. When we test for correlations in elevation categories and adjust the p value for multiple comparison we are left with only 0 ASVs.

NO evidence of a core ASV community associated with Mimulus or elevation types.
